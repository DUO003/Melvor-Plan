extends Node

class 弱网服务端:
	var 服务端:引擎.网络类.UDP服务端
	#var 端口=25555
	##数据
	var 数据_账号表={}
	var 数据_聊天={}
	var 数据_排行榜 = {} 
	var 数据_储存={}
	##临时令牌,不储存 
	var 令牌表={"账号表"={},"令牌表"={}}
	var 启动令牌=false #在使用登入账号API的时候 会自动启动,直到服务端重启
	##
	func ___计时器():#这是内部自动存档计时器
		var 储存账号文件=引擎.字符串.Json_到字符串(self.数据_账号表)
		var 储存聊天文件=引擎.字符串.Json_到字符串(self.数据_聊天)
		var 储存排行榜文件=引擎.字符串.Json_到字符串(self.数据_排行榜)
		var 储存文件=引擎.字符串.Json_到字符串(self.数据_储存)
		
		print("每30秒储存")
		引擎.文件.保存文本到文件(储存账号文件,引擎.文件.获取当前运行目录()+"/数据账号.json")
		引擎.文件.保存文本到文件(储存聊天文件,引擎.文件.获取当前运行目录()+"/数据聊天.json")
		引擎.文件.保存文本到文件(储存排行榜文件,引擎.文件.获取当前运行目录()+"/数据排行榜.json")
		引擎.文件.保存文本到文件(储存文件,引擎.文件.获取当前运行目录()+"/数据储存.json")
		
		
		await 引擎.场景.等待(30)
		___计时器()
	
	
	func ___读档():#首次读档使用
		if 引擎.文件.是否存在(引擎.文件.获取当前运行目录()+"/数据储存.json"):
			var 数据文本=引擎.文件.读取文件到文本(引擎.文件.获取当前运行目录()+"/数据储存.json")
			self.数据_储存=引擎.字符串.Json_到数据(数据文本)
			print("发现储存数据,数据读取成功,路径:",引擎.文件.获取当前运行目录()+"/数据储存.json")
			
			
		if 引擎.文件.是否存在(引擎.文件.获取当前运行目录()+"/数据排行榜.json"):
			var 数据文本=引擎.文件.读取文件到文本(引擎.文件.获取当前运行目录()+"/数据排行榜.json")
			self.数据_排行榜=引擎.字符串.Json_到数据(数据文本)
			print("发现排行榜数据,数据读取成功,路径:",引擎.文件.获取当前运行目录()+"/数据排行榜.json")
			
			
		if 引擎.文件.是否存在(引擎.文件.获取当前运行目录()+"/数据聊天.json"):
			var 数据文本=引擎.文件.读取文件到文本(引擎.文件.获取当前运行目录()+"/数据聊天.json")
			self.数据_聊天=引擎.字符串.Json_到数据(数据文本)
			print("发现聊天数据,数据读取成功,路径:",引擎.文件.获取当前运行目录()+"/数据聊天.json")
			
		if 引擎.文件.是否存在(引擎.文件.获取当前运行目录()+"/数据账号.json"):
			var 数据文本=引擎.文件.读取文件到文本(引擎.文件.获取当前运行目录()+"/数据账号.json")
			self.数据_账号表=引擎.字符串.Json_到数据(数据文本)
			print("发现文件数据,数据读取成功")
		#	self.___计时器()
		#else:
		self.___计时器()
	func 启动监听(端口:int=25555):
		print("启动监听")
		self.服务端 = 引擎.网络.UDP_创建服务端()
		var err=self.服务端.UDP_启动服务(端口)  # 启动服务端，监听25555端口
		引擎.调试.打印("启动"+str(端口)+"端口,状态"+str(err))
		self.___读档()
		
	pass
	func 处理数据(回调字典: Dictionary = {}):
		if self.服务端:
			self.服务端.UDP_处理数据({# 传递回调字典，集中处理事件
				"客户端进入": func(客户端, 客户端IP, 客户端端口):
#					引擎.调试.打印("新客户端进入：%s : %s" % [客户端IP,客户端端口])
					#self.服务端.UDP_发送给客户端(客户端, "欢迎连接！", "utf8")
					if "客户端进入" in 回调字典 and 回调字典["客户端进入"] is Callable:			
						回调字典["客户端进入"].call(客户端, 客户端IP, 客户端端口)
					,
				"服务端收到消息": func(客户端, 数据, 客户端IP, 客户端端口):
					var 文本数据 = 引擎.网络.字节转字符串(数据)
#					引擎.调试.打印("收到[%s:%s]的消息：%s" %[客户端IP,客户端端口,文本数据])
					#self.服务端.UDP_发送给客户端(客户端, "服务端已收到：" + 文本数据, "utf8")
					#也会转发出去
					if "服务端收到消息" in 回调字典 and 回调字典["服务端收到消息"] is Callable:
						回调字典["服务端收到消息"].call(客户端, 数据, 客户端IP, 客户端端口)
					
					##API处理 
					var a=self._API(客户端,文本数据)
				
					self.发送数据(客户端,a, "utf8")	
			})
			
			pass
	func 发送数据(客户端, 数据, 编码类型: String = "utf8"):
		self.服务端.UDP_发送给客户端(客户端,数据, 编码类型)	
	func 广播数据(数据, 编码类型: String = "utf8"):
		self.服务端.UDP_广播数据(数据, 编码类型)
	func _API(客户端,文本数据):
		var 收到的数据=引擎.字符串.Json_到数据(文本数据)
		if 收到的数据==null:
			return {"类型":"异常","数据":"异常js","状态":"失败"}
		if 收到的数据!=null:
			if ("类型" in 收到的数据)==false:#print("无类型")
				return {"类型":"异常","数据":"异常LX","状态":"失败"}
			if ("类型" in 收到的数据)==true:
				##print("收到的类型:",收到的数据.类型)
				##检测令牌
				if self.启动令牌==true:
					if "令牌" in 收到的数据:
						#if (收到的数据.令牌 in self.令牌表["令牌表"])==true:
							#print("这个令牌有,通过")
						if (收到的数据.令牌 in self.令牌表["令牌表"])==false:
							return {"类型":"异常","数据":"异常数据LP","状态":"失败"}
							
				#
				if has_method("__"+收到的数据.类型):
					return call("__"+收到的数据.类型,收到的数据)
		pass
	func __账号注册(请求数据):#类型 账号 密码 账号限制字符
		#print("准备注册",请求数据)
		var 返回状态 = "成功";
		var 返回文本 = "注册成功";
		var 特殊符号=false
		if 请求数据.账号限制字符==true:
			特殊符号=引擎.字符串.正则匹配(请求数据.账号,"^[A-Za-z0-9][A-Za-z0-9_]*$")==""
		#禁止注册 #未开放注册
		#检查特殊符号
		if 特殊符号==true:
			返回状态="失败"
			返回文本="账号不允许特殊符号注册"
		#检查重复账号
		if (请求数据.账号 in self.数据_账号表)==true:
			返回状态="失败"
			返回文本="注册失败,账号已重复"
		#写入账号
		if 返回状态=="成功":
			self.数据_账号表[请求数据.账号]={}
			self.数据_账号表[请求数据.账号]={"账号":请求数据.账号,"密码":引擎.加解密.字符串加密(请求数据.密码),"黑名单":"0"}			
		return {"类型": "账号注册","状态": 返回状态,"数据": 返回文本}
		
	func __账号登入(请求数据):#类型 账号 密码 
		var 返回状态 = "失败";
		var 返回文本 = "登入失败,密码错误";
		var 是否存在账号=(请求数据.账号 in self.数据_账号表)
		#找不到用户
		if 是否存在账号 == false:
			返回文本 = "登入失败,找不到用户";
			返回状态 = "失败";
		#成功登入
		if 是否存在账号==true:
			if 引擎.加解密.字符串解密(self.数据_账号表[请求数据.账号]["密码"])==请求数据.密码:
				返回文本 = "成功登入,密码验证成功";
				返回状态 = "成功";
				#标记 这个服务端开始已令牌检查数据是否合法了
				self.启动令牌=true #
				#登入成功,会申请令牌
				if (请求数据.账号 in self.令牌表["账号表"])==true:
					#有码删除
					var 以前的令牌=self.令牌表["账号表"][请求数据.账号]
					self.令牌表["账号表"].erase(请求数据.账号)
					self.令牌表["令牌表"].erase(以前的令牌)
				#写入申请码
				var 申请令牌码=self.__申请令牌()+请求数据.账号
				self.令牌表["令牌表"][申请令牌码]=请求数据.账号
				self.令牌表["账号表"][请求数据.账号]=申请令牌码
				#
				return {"类型": "账号登入","状态": 返回状态,"数据": 返回文本,"令牌":申请令牌码}
			if self.数据_账号表[请求数据.账号]["黑名单"]=="1":
				返回文本 = "此账号已被封号";
				返回状态 = "失败";
		return {"类型": "账号登入","状态": 返回状态,"数据": 返回文本}
	func __申请令牌():
		return 引擎.字符串.获取不重复随机码()
		pass
	
	var 临时存档数据库={}
	func __临时存档申请(请求数据):
		var 兑换码 =引擎.字符串.获取不重复随机码()
		# 临时存储数据
		self.临时存档数据库[兑换码] = 请求数据.数据
		
		引擎.调试.注释打印("临时存储成功，兑换码: ", 兑换码)
		# 返回结果给客户端
		return {"类型": "临时存档申请","状态": "成功","数据": 兑换码}
	func __临时存档兑换(请求数据):
		var 兑换码 = 请求数据.数据
		if (兑换码 in self.临时存档数据库)==false:
			return {"类型": "临时存档兑换","状态": "失败","数据": ""}
		if (兑换码 in self.临时存档数据库)==true:
			var _数据 = self.临时存档数据库[兑换码]
			self.临时存档数据库.erase(兑换码)
			return {"类型": "临时存档兑换","状态": "成功","数据": _数据}
	
	func __账号重置密码():
		pass
	func __账号封号():
		pass
	func __txt_写入日志():
		pass
		
	func ___初始化聊天(标记:String):
		if (标记 in self.数据_聊天)==false:
			self.数据_聊天[标记] = []
		
	func __聊天请求(请求数据):
		var 标记 = 请求数据.标记
		___初始化聊天(标记)
		
		var 消息时间戳=引擎.时间.取当前时间戳()
		var 新消息 = {
		"时间戳": 消息时间戳,
		"发送者": 请求数据.发送者,
		"文本": 请求数据.文本,
		"数据": 请求数据.数据 if "数据" in 请求数据 else {}  # 处理可选的额外数据
		}
		
		# 添加到对应频道的聊天记录
		self.数据_聊天[请求数据.标记].append(新消息);
		# 如果超过最大记录数，移除最旧的消息
		while self.数据_聊天[请求数据.标记].size() > 50:
			self.数据_聊天[请求数据.标记].pop_front()  # 移除数组第一个元素（最旧的）
		 # 返回成功响应
		#广播数据
		var 广播数据=请求数据
		广播数据.时间戳=消息时间戳
		广播数据.类型="广播聊天"
		self.服务端.UDP_广播数据(广播数据, "utf8")
		#返回个人
		return {"类型":"聊天请求","状态":"成功","数据":"发送成功"}
		pass
	func __聊天获取(请求数据):
		var 标记 = 请求数据.标记
		# 确保频道存在（即使是空的）
		___初始化聊天(标记)
		
		# 可选：支持获取最新的N条记录，默认获取全部
		var 获取数量 = 请求数据.获取数量 if "获取数量" in 请求数据 else 50
		获取数量 = clamp(获取数量, 1, 50)  # 限制在1到最大记录数之间
		
		# 计算起始索引，获取最新的N条记录
		var 起始索引 = max(0, self.数据_聊天[标记].size() - 获取数量)
		var 返回的记录 = self.数据_聊天[标记].slice(起始索引)
		return {"类型": "聊天获取","状态": "成功","标记": 标记,"数据": 返回的记录}
	func __PING(请求数据):
		#print("只为心跳包")
		return {"类型":"PING","状态":"成功"}
	func __时间戳(请求数据):
		return {"类型":"时间戳","状态":"成功","数据":引擎.时间.取当前时间戳()}
		pass
	func __伪随机():
		pass
		
	
	func ___初始化排行榜(标记: String) -> void:
		if 标记 not in self.数据_排行榜:
			self.数据_排行榜[标记] = []
	func __排行榜写入(请求数据):
		var 标记 = 请求数据.标记
		___初始化排行榜(标记)  # 确保排行榜存在
		
		# 构造排行项
		var 新排行项 = {
			"玩家ID": 请求数据.玩家ID,
			"分数": 请求数据.分数,
			"数据": 请求数据.数据 if "数据" in 请求数据 else {},
			"更新时间": 引擎.时间.取当前时间戳()
		}
		# 检查该玩家是否已有记录，有则更新
		var 已有记录索引 = -1
		for i in range(self.数据_排行榜[标记].size()):
			if self.数据_排行榜[标记][i].玩家ID == 请求数据.玩家ID:
				已有记录索引 = i
				break
		if 已有记录索引 != -1:
			# 只在新分数更高时更新（可根据需求修改）
			if 新排行项.分数 > self.数据_排行榜[标记][已有记录索引].分数:
				self.数据_排行榜[标记][已有记录索引] = 新排行项
		else:
			self.数据_排行榜[标记].append(新排行项)
		
		# 按分数排序（降序，分数高的在前）
		self.数据_排行榜[标记].sort_custom(func(a, b):
			return a.分数 > b.分数
		)
		
		# 限制记录数量，超过则移除末尾（分数最低的）
		while self.数据_排行榜[标记].size() > 50:
			self.数据_排行榜[标记].pop_back()
		
		# 查找当前玩家的排名
		var 玩家排名 = 0
		for i in range(self.数据_排行榜[标记].size()):
			if self.数据_排行榜[标记][i].玩家ID == 请求数据.玩家ID:
				玩家排名 = i + 1  # 排名从1开始
				break
		#print(self.数据_排行榜[标记])
		return {
			"类型": "排行榜写入",
			"状态": "成功",
			"数据": 玩家排名,
		}
		pass
	func __排行榜获取(请求数据):
		var 标记 = 请求数据.标记
		___初始化排行榜(标记)  # 确保排行榜存在
		# 确定要返回的记录数量（默认前20名）
		var 获取数量 = 请求数据.获取数量 if "获取数量" in 请求数据 else 10
		获取数量 = clamp(获取数量, 1, 50)
		
		# 截取前N名记录
		var 返回的排行 = self.数据_排行榜[标记].slice(0, 获取数量)
		
		# 可选：返回当前玩家的个人排名（如果提供了玩家ID）
		var 个人排名 = null
		if "玩家ID" in 请求数据:
			for i in range(self.数据_排行榜[标记].size()):
				if self.数据_排行榜[标记][i].玩家ID == 请求数据.玩家ID:
					个人排名 = i + 1
					break
		
		return {
			"类型": "排行榜获取",
			"状态": "成功",
			"数据": 返回的排行,
			"个人排名": 个人排名  # 非前N名也能知道自己的排名
		}
		pass
		
		
	
	func 初始化存储分类(标记: String) -> void:
		if 标记 not in self.数据_储存:
			self.数据_储存[标记] = {}
	func __储存申请(请求数据):
		var 标记 = 请求数据.标记
		var 新数据 = 请求数据.数据
		初始化存储分类(标记)  # 确保分类存在
		
		# 遍历新数据，更新或插入到存储中
		for 键 in 新数据:
			self.数据_储存[标记][键] = 新数据[键]
		#print(self.数据_储存)
		# 返回更新后的完整数据
		return {
			"类型": "储存申请",
			"状态": "成功",
			"数据": "成功",
		}
	func __储存查询(请求数据):

		var 标记 = 请求数据.标记
		初始化存储分类(标记)  # 确保分类存在（即使是空的）
		
		# 确定需要返回的字段
		var 需查询字段 = []
		if "数据" in 请求数据 and typeof(请求数据.数据) == TYPE_ARRAY and 请求数据.数据.size() > 0:
			需查询字段 = 请求数据.数据  # 使用指定的查询字段
		else:
			# 没有指定字段或格式不正确，返回全部数据
			需查询字段 = self.数据_储存[标记].keys()
		
		# 组装查询结果
		var 查询结果 = {}
		for 键 in 需查询字段:
			if 键 in self.数据_储存[标记]:
				查询结果[键] = self.数据_储存[标记][键]
			else:
				查询结果[键] = null  # 字段不存在时返回null
		
		return {
			"类型": "储存查询",
			"状态": "成功",
			"数据": 查询结果
		}
func 创建弱网服务端() -> 弱网服务端:
	var 弱网=弱网服务端.new()
	return 弱网

class 弱网客户端:
	var 令牌="" #没有就空,有就自动传输令牌
	var 客户端: 引擎.网络类.UDP客户端
	func __心跳包():
		await 引擎.场景.等待(200)
		var 数据={"类型":"PING"}
		self.客户端.UDP_发送数据(数据,"utf8")
		__心跳包()
	func 连接(ip="127.0.0.1",端口=25555):
		self.客户端=引擎.网络.UDP_创建客户端()
		self.客户端.UDP_连接(ip,端口)
		__心跳包() #启动心跳包
		
	func 发送数据(数据:Dictionary,编码类型:Variant="utf8"):
		if self.令牌!="":
			数据.令牌=self.令牌
		self.客户端.UDP_发送数据(数据,"utf8")
	func 处理数据(回调字典: Dictionary = {}):
		self.客户端.UDP_处理数据({
			"客户端收到消息": func(数据):
				if "客户端收到消息" in 回调字典 and 回调字典["客户端收到消息"] is Callable:
					数据=引擎.字符串.Json_到数据(数据)
					回调字典["客户端收到消息"].call(数据)
		#			var z=引擎.字符串.Json_到数据(数据)
					if 数据.类型=="账号登入":
						if 数据.状态=="成功":
							self.令牌=数据.令牌
							#print("客户端令牌记录了:",self.令牌)
				,	
			})
		pass
func 创建弱网客户端() -> 弱网客户端:
	var 弱网=弱网客户端.new()
	return 弱网
