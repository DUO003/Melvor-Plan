#@tool
#extends Node
###游戏的任务逻辑
#class_name 任务类
##任务表
#static var 角色任务={}
###任务的状态
#enum 任务_状态{
	#未解锁,##@author 做着名称
   	#已解锁,##代表可接收可查看的任务状态
	#已接收,##已经接收了任务状态
	#可完成,##可以完成交付的任务状态
	#已完成##已经完成领奖的状态
#}
###需要刷新任务显示的信号
###需要把任务的数据库加载进来,初始玩家的任务表,没有的就插入到未解锁
#static func 初始化任务表(网络数据表:Dictionary):
	#for i in 网络数据表:
		#if ("任务ID" in 角色任务)==false:
			#角色任务[i]={"任务ID"=i,"任务状态"=任务_状态.未解锁,"任务完成时间"=-1}
###自检任务表 从未解锁到已解锁,从已接收到可完成
#static func 自检任务(网络数据表:Dictionary):
	##解锁规则检测
	##从未解锁到已解锁
	#for i in 角色任务:
		##从未解锁到已解锁
		#if 角色任务[i].任务状态==任务_状态.未解锁:
			#if 是否完成规则(网络数据表[i].解锁规则)==true:
				#角色任务[i].任务状态=任务_状态.已解锁
		##从已接收到可完成
		#if 角色任务[i].任务状态==任务_状态.已接收:
			#if 是否完成规则(网络数据表[i].达成规则)==true:
				#角色任务[i].任务状态=任务_状态.可完成
	#pass
###规则切割,自己定义的规则 需要转到字典
###解锁规则:需求等级&3
###[
###[0]={ "类型": "需求等级", "需求等级": "3" }
###]
#static func 规则切割(规则:String) -> Array:
	#var 返回的规则组=[]
	##print("----------轮回-------------")
	#print("解锁规则:",规则)
	#var 解锁规则=规则
	#var 加号切割=解锁规则.split("+")
	#for u in 加号切割:
		#var 单条解锁规则=u
		#var 分号切割=单条解锁规则.split("&")
		##print(分号切割)
		###自定义的规则加入
		#if 分号切割[0]=="需求等级":
			#返回的规则组.append({"类型":分号切割[0],分号切割[0]:分号切割[1]})
		#if 分号切割[0]=="需求道具" or 分号切割[0]=="道具":
			#返回的规则组.append({"类型":分号切割[0],"道具ID":分号切割[1],"道具数量":分号切割[2]})
		#if 分号切割[0]=="杀敌数量":
			#返回的规则组.append({"类型":分号切割[0],"怪物名称":分号切割[1],"怪物数量":分号切割[2]})
		#if 分号切割[0]=="完成任务":
			#返回的规则组.append({"类型":分号切割[0],"完成任务":分号切割[1]})	
						#
	##print("-------------轮回结束---------\n\n")		
	#return 返回的规则组
	#pass
###用于检测规则是否完成,自定义
#static func 是否完成规则(解锁规则:String)-> bool:
	#var 是否完成=true #先让他完成吧,后面不行就拦截
	#for j in 规则切割(解锁规则):
		#if j.类型=="需求等级":
			##print(j.需求等级,Global.角色等级<int(j.需求等级))
			#if Global.角色等级<int(j.需求等级):
				#是否完成=false#拦截
		#if j.类型=="杀敌数量":
##			print(j.怪物名称)
##			print(j.怪物数量)
			#if 计次储存.获取_计次变量_不过期变量("杀敌_"+str(j.怪物名称)) < int(j.怪物数量):
				##没完成
				#是否完成=false
		#if j.类型=="完成任务":
			#if 角色任务[str(j.完成任务)].任务状态 != 任务_状态.已完成:
				#是否完成=false#不在完成的状态则拦截
		#if j.类型=="需求道具" or j.类型=="道具":
			#if int(背包类.取道具在背包里的数量(int(j.道具ID)))<int(j.道具数量):
				#是否完成=false#少于数量则拦截
			##print(j.道具ID)
			##print(j.道具数量)	
	#return 是否完成
###用于接收任务 从1已解锁到2已接收
#static func 接收任务(任务ID):
	#if 角色任务[任务ID].任务状态==任务_状态.已解锁:
		#角色任务[任务ID].任务状态=任务_状态.已接收
		#
	#pass	
	#
###用于完成任务 从3到到4 自定义奖励
#static func 完成任务(任务ID):
	#if 角色任务[str(任务ID)].任务状态==任务_状态.可完成:
		#角色任务[任务ID].任务状态=任务_状态.已完成
		#for j in 规则切割(Excel.任务数据库[str(任务ID)].奖励规则):
			#if j.类型=="道具":
				#背包类.添加物品(int(j.道具ID),int(j.道具数量))
		#pass
	#
#static func _static_init() -> void:##只有在打开tool,且在工程内才会输出
	#调试输出.打印("工程调试专用.tools下会执行任务类!")
	#pass
###运行游戏后 在gamemode执行这里
#static func 开始运行():
	#任务类.初始化任务表(Excel.任务数据库)
#
