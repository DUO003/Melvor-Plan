extends Node
#region 变量与信号声明
# 定义用户数据存储路径
#const 存档路径 = "user://存档.json"
var 存档路径: String = "user://"
var 存档名称: String = "存档.tres"
# 用于存储玩家数据的字典
var 提示容器
var 梅存档 = {}

var 配置文件:Dictionary={}
##默认为空字典
#参数:值(文本类参数已数组表示所有可能值)
#通知位置:["左", "中", "右"]
static var 首次加载 = true
var 堆叠上限修改={}

var 矿石上限: float
var 木材上限: float
var 皮革上限: float
var 药草上限: float
var 零件上限: float
var 精华上限: float
var 体力恢复速度: int = 360
var 恢复量: int = 1
var 玩家单例: 玩家功能 = 玩家功能.new()

var 材料对照 = {# 定义材料和属性的对照字典
		"矿石": "矿石",
		"木材": "木材",
		"皮革": "皮革",
		"药草": "药草",
		"零件": "零件",
		"精魄": "精魄"}
var 物品字典: Dictionary[String, ItemData] = {}
#所有物品在游戏运行时会存到字典中,充能装备除外
var 时间戳字典:Dictionary[String,int] = {}#单独存档
#存档加载时获取,为空时需要创建.注意本游戏仅支持整数时间戳.
var 节点={}
# 缓存节点 方便跨场景调用,不保证有效
var 今日零点:int
var 商店刷新计时器: Timer = null
var 装备序号=0
signal 更新_UI()
@warning_ignore("unused_signal")
signal 购买物品(物品: ItemData, 容器名: String)
@warning_ignore("unused_signal")
signal 更新_背包物品信息(物品:标准物品)
#endregion
#region 节点就绪
# 节点初始化完成时自动调用
@warning_ignore("unused_private_class_variable")
var 测试=0
func _ready() -> void:
	if 首次加载:
		首次加载 = false
		_配置背包()
		_读档()
		初始化资源上限()
		await 保存存档()
		#调试精通()
		
	玩家单例.更新属性()
	创建计时器(1.0, Callable(self, "体力检查"))# 封装计时器方法每秒 检查体力恢复 
	今日零点=获取零点时间戳()
	#print("测试0",Time.get_unix_time_from_system())
	#print("测试1",获取零点时间戳(99,1759334300))
	#print("测试2",获取零点时间戳(100,1759334300))
	#print("测试3",获取零点时间戳(0,1759420800))
	创建计时器((获取零点时间戳()-Time.get_unix_time_from_system()), Callable(self, "零点检测"),false,true)# 封装计时器方法每5秒 1.检查门票过期,研究费用重置
	创建或更新商店刷新计时器()
#endregion
#region 废弃代码(纪念用,不使用)
# 增加或减少物品数量#废弃方法添加物品
func 获得物品(物品名称, 数量, _参数 = null):
	var 背包 = 梅存档.get("背包", {})
	# 如果物品已存在，增加或减少数量
	数量 = int(数量)  # 强制转换为整数
	if 背包.has(物品名称):
		var 当前数量 = 背包[物品名称]
		var 新数量 = 当前数量 + 数量
		# 处理数量小于等于0的情况
		if 新数量 <= 0:
			背包.erase(物品名称)  # 数量小于等于0时移除物品
		else:
			背包[物品名称] = 新数量  # 更新物品数量
			print("物品 '" + 物品名称 + "' 数量更新为 " + str(新数量))
	else:
		# 物品不存在且数量为正数时，添加新物品
		if 数量 > 0:
			背包[物品名称] = 数量
		else:
			print("无法减少不存在的物品 '" + 物品名称 + "'")
	# 更新背包数据并保存
	梅存档["背包"] = 背包
# 读取物品数量，支持自定义默认值
func 读取物品(物品名称, 默认值 = 0):
	# 获取背包数据，不存在则创建空字典
	var 背包 = 梅存档.get("背包", {})
	
	# 检查物品是否存在并返回对应数量
	if 背包.has(物品名称):
		return 背包[物品名称]
	else:
		return 默认值
#endregion
#region 内部实现(通常不在其他代码使用)
func _配置背包() -> void:
	GBIS.current_save_path = 存档路径# 设置保存路径
	GBIS.current_save_name = 存档名称# 设置存档名称
	GBIS.inventory_service.regist("背包", 9, 10, false, ["ANY"])
	GBIS.inventory_service.regist("装备", 8, 4, false, ["装备"])
	GBIS.inventory_service.regist("随身商店", 5, 10, true, ["ANY"])
func 初始化资源上限():
	var 等级=梅存档.get("手工", {}).get("等级", 1)# 计算基础资源的基础数值公式
	var 基础数值 = floor((120 + 等级 * 10) * (1 + 0.01 * 等级))
	矿石上限 = 基础数值# 前4种基础资源直接使用基础数值
	木材上限 = 基础数值
	皮革上限 = 基础数值
	药草上限 = 基础数值
	零件上限 = floor(40 + 等级 * 8)# 零件资源单独计算
	精华上限 = 1.79769e308# 精华无上限
func _读档():# 从文件加载玩家数据，不存在则创建新存档
	GBIS.load()
	var 修复存档=初始化存档数据(梅存档)
	if 梅存档 != 修复存档:
		梅存档 = 修复存档
		保存存档()
	## 旧版本 检查文件是否存在
	#if FileAccess.file_exists(存档路径):
		## 文件存在时读取数据
		#var file = FileAccess.open(存档路径, FileAccess.READ)
		#var content = file.get_as_text()
		#梅存档 = JSON.parse_string(content)
		#print("存档加载成功")
	#else:
		## 文件不存在时创建新存档
		#创建初始存档数据()
		#print("创建新存档")
# 创建初始存档数据
func 初始化存档数据(原始存档数据):
	# 定义标准存档结构（写死在方法内）
	var 标准存档 = {
		"金币": 0,
		"挂机":{},
		"手工": {
			"矿石": 100,
			"木材": 100,
			"皮革": 100,
			"药草": 100,
			"零件": 100,
			"精华": 0,
			"标准剑":1
		},
		"游历":{},
	}
	var 处理后存档 = {}
	if 原始存档数据 is Dictionary:
		处理后存档 = 原始存档数据.duplicate(true)  # 深拷贝避免修改原始数据
			# 对比并补齐浅层键
		for 键 in 标准存档.keys():
			if not 处理后存档.has(键):
				if 标准存档[键] is Dictionary or 标准存档[键] is Array:
					处理后存档[键] = 标准存档[键].duplicate(true)# 缺失时添加完整的深层结构
				else:
					处理后存档[键] = 标准存档[键]
	else:# 处理空存档情况（如传入"{}"）
		# 如果原始存档为空，直接使用标准存档作为基础
		处理后存档 = 标准存档.duplicate(true)
	return 处理后存档
func 检查物品是否存在(目标名称: String) -> bool:
	for 物品数据 in 物品字典.values():# 遍历字典中所有ItemData资源
		if 物品数据.item_name == 目标名称:# 对比物品名称（区分大小写）
			return true
	return false# 未找到匹配的物品
# 填充物品到物品字典
# 参数: 物品名称 - 作为物品字典的键; 数据字典 - 包含物品属性的字典
func 填充物品(物品名称: String, 数据字典: Dictionary={}):
	if 检查物品是否存在(物品名称):
		return 物品字典[物品名称].duplicate()
	if 数据字典=={}:
		数据字典=梅表格.获取表格字典(梅表格.装备蓝图,0,物品名称)
	var 转译映射: Dictionary = {# 定义属性转译映射(数据字典键: 道具属性名)
		"名称": "item_name",
		"堆叠": "stack_size",}
	var 道具 = load("res://道具/标准物品.tres")# 构建道具资源路径并加载
	if not 道具:
		print("无法加载道具资源: ", 道具)
		return
	# 获取道具所有属性列表并转换为字典(键:属性名, 值:属性类型)
	var 属性列表 = 道具.get_property_list()
	var 属性类型字典: Dictionary = {}
	for 属性 in 属性列表:
		属性类型字典[属性.name] = 属性.type  # 存储属性名与类型的映射关系
	# 设置物品名称(优先使用传入的物品名称参数)
	道具.item_name = 物品名称
	道具.columns=1#物品不在应用尺寸属性,该属性为装备专属
	道具.rows=1
	# 遍历数据字典处理属性
	for 数据键 in 数据字典:
		# 获取转译后的属性名,如果没有转译规则则使用原键
		var 道具属性名 = 转译映射.get(数据键, 数据键)
		# 检查道具是否存在该属性(直接从属性类型字典判断)
		if 属性类型字典.has(道具属性名):
			var 属性 = 道具.get(道具属性名)# 直接获取属性
			var 要设置的值 = 数据字典[数据键]# 准备要设置的值
			if 属性 is Texture2D:
				var 加载的纹理 = load(要设置的值)
				if 加载的纹理:
					print("加载纹理资源: ", 要设置的值)
					要设置的值 = 加载的纹理
				else:
					print("警告: 无法加载纹理资源: ", 要设置的值)
			道具.set(道具属性名, 要设置的值)# 赋值属性
			print(数据键,"属性: ", 道具属性名, "=", 要设置的值)
		else:
			pass# 忽略多余的属性
	物品字典[物品名称] = 道具# 将处理好的道具存入物品字典(以物品名称为键)
	return 道具.duplicate()
# 填充物品到物品字典
# 参数: 物品名称 - 作为物品字典的键; 数据字典 - 包含物品属性的字典
func 初始化装备(物品蓝图名: String):
	# 构建道具资源路径并加载
	var 蓝图信息=梅表格.获取表格字典(梅表格.装备蓝图,0,物品蓝图名)
	#print("蓝图信息: ", 蓝图信息)
	var 装备路径 = "res://道具/装备物品.tres"
	var 装备 = load(装备路径)
	if not 装备:
		print("无法加载装备资源: ", 装备路径)
		return
	装备.item_name = 生成装备名(物品蓝图名)
	装备.icon=load(蓝图信息["icon"])
	装备.蓝图名称=物品蓝图名
	装备.columns=int(蓝图信息["列"])
	装备.rows=int(蓝图信息["行"])
	装备.覆盖更新(蓝图信息["分类"],蓝图信息["类型"],蓝图信息["职业"],int(蓝图信息["阶级"]))
	return 装备
# 生成唯一装备名称的工具函数
func 生成装备名(蓝图名: String) -> String:
	var 当前时间戳: int = int(Time.get_unix_time_from_system())# 1. 获取当前时间戳（浮点转整数，取整到秒，去掉小数）
	装备序号 += 1# 2. 当前序号+1
	return "%s_%d_%d" % [蓝图名, 当前时间戳, 装备序号]# 3. 组合名称：蓝图名_整数时间戳_序号
func 属性是否存在(对象: Object, 属性名: String) -> bool:# 辅助函数：检查对象是否存在指定属性
	# 获取对象所有属性列表
	var 属性列表 = 对象.get_property_list()
	for 属性 in 属性列表:
		if 属性.name == 属性名:
			return true
	return false
func 精通熟练需求(等级:int,基础=20,成长=0.05, 倍率 = 0) -> int:
	## 基础 不同系统内固定的基础不同最低20 ③手工系统=25
	## 成长 精通玩法 固定为0.07,熟练固定为0.1
	## 倍率 系统倍率5,系统内玩法为0.5
	if 等级 == 100 or 等级 < 0 or 等级 > 100:
		#push_warning("等级必须在0-99范围内")
		return -1
	var 基础值 = 基础 * ((1.0+成长)** 等级) + (基础**((倍率/(1.0+倍率))+1)) * (50 if 等级 > 50 else 等级)
	var 最终值 = 基础值 * (1.0 + (0.75 ** (等级 / 20.0)) * 倍率)
	return round(最终值)
func 调试精通(基础=25,成长=0.07, 倍率 = 0.5):
	print("调试精通")
	print("---------------------------------------------------------")
	var 总精通=0
	for 等级 in range(0, 100):
		var 精通=精通熟练需求(等级,基础,成长, 倍率)
		总精通+=精通
		var 天数 = 总精通/ 86400.0
		print("等级:%d = %d, 总精通: %d (%d)天" % [等级, 精通,总精通,天数])
func 体力检查():
	var 挂机数据 = 梅存档["挂机"]
	var 体力上限: int = 挂机数据.get("体力上限", 240)
	var 体力值: int = 挂机数据.get("体力值", 240)
	var 时间差: int = 处理时间戳("体力回复")
	if 时间差 >= 体力恢复速度:
		@warning_ignore("integer_division")
		var 恢复次数 = 时间差 / 体力恢复速度  # 保持原除法逻辑（忽略警告）
		var 理论恢复总量 = 恢复次数 * 恢复量
		var 实际恢复量 = min(理论恢复总量, 体力上限 - 体力值)
		if 实际恢复量 > 0:
			体力值 += 实际恢复量  # 更新体力值
			# 5. 将更新后的体力值写回嵌套字典（关键：确保存档生效）
			挂机数据["体力值"] = 体力值  # 因为字典是引用类型，直接修改会同步到梅存档["挂机"]
		# 6. 更新时间戳（假设时间戳字典仍独立，若也在存档中需同步修改）
		初始化.时间戳字典["体力回复"] += 恢复次数 * 体力恢复速度
		保存存档()
	else :
		挂机数据["体力值"] = 体力值
		# 7. 发射UI更新信号
		emit_signal("更新_UI")
func 零点检测(计时器=null):
	if 计时器 and is_instance_valid(计时器) and 计时器 is Timer:
		计时器.wait_time = (获取零点时间戳(1)-Time.get_unix_time_from_system())#重制下一天0点时间戳,+1秒防止重复执行
	时间戳字典.erase("研究时间戳")#如果时间戳字典存在研究时间 清空
	梅存档["手工"].erase("研究费用")
	var 挂机数据 = 初始化.梅存档["挂机"]#门票过期逻辑(0点过期部分)
	var 门票=挂机数据.get("门票",{})
	var 门票名: Array = 门票.keys()
	for i in 门票名:
		print(获取零点时间戳(3600,门票[i]))
		if 获取零点时间戳(3600,门票[i])<=今日零点:
			门票.erase(i)
	保存存档()
	emit_signal("更新_UI")
#endregion
#region 便利引用
# 保存玩家数据到文件
func 保存存档():
	GBIS.save()
	#var file = FileAccess.open(存档路径, FileAccess.WRITE)
	#file.store_string(JSON.stringify(梅存档))
	print("存档已保存")
# 计算剩余倒计时秒数（确保非负）
func 获取剩余秒数(目标时间戳: int) -> int:#用于计时器,不可小于1
	return max(int(目标时间戳 - Time.get_unix_time_from_system()), 1)
func 格式化时间(总秒数: int) -> String:
	if 总秒数 < 0:
		return "00:00:00"  # 确保非负
	@warning_ignore("integer_division")
	var _小时: int = 总秒数 / 3600  # 1小时=3600秒
	var 剩余秒数 = 总秒数 % 3600  # 除去小时后的剩余秒数
	@warning_ignore("integer_division")
	var _分钟 = 剩余秒数 / 60  # 1分钟=60秒
	var _秒 = 剩余秒数 % 60  # 最终剩余秒数
	# 用字符串格式化补零（确保每位都是两位数）
	return "%02d:%02d:%02d" % [_小时, _分钟, _秒]
func 创建或更新商店刷新计时器():
	var 缓存时间戳=int(时间戳字典.get("商店刷新", Time.get_unix_time_from_system()))
	var 剩余秒数=获取剩余秒数(缓存时间戳)
	print("商店刷新计时器剩余秒数:",剩余秒数)
	if 商店刷新计时器 == null or 商店刷新计时器.wait_time<=1:
		商店刷新计时器 = 创建计时器(剩余秒数, Callable(self, "商店刷新"),false)
	else:
		print("计时器剩余秒数:",商店刷新计时器.wait_time)
		商店刷新计时器.wait_time = 剩余秒数
func 商店刷新():
	var 缓存零点时间戳=获取零点时间戳()
	var 缓存当前时间=Time.get_unix_time_from_system()
	if "商店刷新" in 时间戳字典:
		print("时间戳字典中存在'商店刷新'键，值为:", 时间戳字典["商店刷新"])
	else:
		print("时间戳字典中不存在'商店刷新'键")
	if 缓存零点时间戳-缓存当前时间 > 7200:
		时间戳字典["商店刷新"]=int(缓存当前时间+7200)
	else :
		时间戳字典["商店刷新"]=int(获取零点时间戳())
	print("商店下次刷新时间戳:",时间戳字典["商店刷新"])
	var 货物数组: Array[ItemData]=商店补货()
	GBIS.shop_service.get_container("随身商店").clear()
	GBIS.shop_service.load_goods("随身商店", 货物数组)
	GBIS.sig_inv_refresh.emit()#更新商店
	创建或更新商店刷新计时器()
func 商店补货():
	var 货物数组: Array[ItemData]=[]
	var 允许货物字典={
	"商店补货总数": 10,
	"货物清单": {
		"蓝图纸": {
			"商店货量": 10,
			"购买数量": 5,
			"价格": 1600,
			"随机_商店货量": 16,
			"随机_购买数量": 10,
			"随机_价格": 8000,
			"最大次数":1
		},
		"铁锭": {
			"商店货量": 3,
			"购买数量": 1,
			"价格": 800,
			"随机_商店货量": 5,
			"随机_购买数量": 5,
			"随机_价格": 1800,
			"最大次数":-1
		},
		"随机礼盒": {
			"商店货量": 1,
			"购买数量": 1,
			"价格": 2000,
			"随机_商店货量": 1,
			"随机_购买数量": 1,
			"随机_价格": 2000,
			"最大次数":-1
		},
		"绿色电路板": {
			"商店货量": 1,
			"购买数量": 1,
			"价格": 1500,
			"随机_商店货量": 5,
			"随机_购买数量": 1,
			"随机_价格": 2500,
			"最大次数":2
		}}}
	var 补货次数 = 允许货物字典["商店补货总数"]
	for i in range(补货次数):
		# 筛选可用货物（最大次数为-1或>0）
		var 可用货物列表 = []
		for 物品名称 in 允许货物字典["货物清单"]:
			var 物品数据 = 允许货物字典["货物清单"][物品名称]
			if 物品数据["最大次数"] == -1 or 物品数据["最大次数"] > 0:
				可用货物列表.append(物品名称)
		if 可用货物列表.size() == 0:
			break
		# 随机抽取物品
		var 选中物品名称 = 可用货物列表[randi() % 可用货物列表.size()]
		var 选中物品数据 = 允许货物字典["货物清单"][选中物品名称]
		# 更新最大抽取次数
		if 选中物品数据["最大次数"] != -1:
			选中物品数据["最大次数"] -= 1
			if 选中物品数据["最大次数"] == 0:
				允许货物字典["货物清单"].erase(选中物品名称)
		# 获取物品实例
		var 当前货物 = 填充物品(选中物品名称)
		print("填充物品:",选中物品名称)
		# 因随机值 ≥ 普通值，直接用普通值作为下限、随机值作为上限
		当前货物.商店剩余数量 = randi_range(选中物品数据["商店货量"], 选中物品数据["随机_商店货量"])
		当前货物.价值 = randi_range(选中物品数据["价格"], 选中物品数据["随机_价格"])
		当前货物.current_amount = randi_range(选中物品数据["购买数量"], 选中物品数据["随机_购买数量"])
		货物数组.append(当前货物)
	return 货物数组
func 获得物品语法糖(物品名称, 数量=1,  类型="标准物品",_参数 = null):
	var 道具
	var 背包类型 = "背包"
	if 类型=="标准物品":
		道具 = 填充物品(物品名称, 梅表格.获取表格字典(梅表格.装备蓝图,0,物品名称))#print("打印字典:",梅表格.获取表格字典(梅表格.装备蓝图, 0, 物品名称))
	elif 类型=="装备物品":
		道具 = 初始化装备(物品名称)
		背包类型 = "装备"
	else:
		道具 = 填充物品(物品名称, {"简介":"数据错误"})
	var 是可堆叠物品 = false# 判断是否为可堆叠物品
	#检查是否继承自StackableData(可堆叠物品)
	if 道具 is StackableData:
		是可堆叠物品 = true
	# 处理可堆叠物品
	if 是可堆叠物品:
		道具.current_amount = 数量
		GBIS.add_item(背包类型, 道具)
	else:# 处理不可堆叠物品
		for i in range(数量):
			# 每次添加都创建新实例，避免引用同一对象
			var 道具实例 = 道具.duplicate()
			GBIS.add_item(背包类型, 道具实例)
func 检查背包物品数量(物品名称)->int:
	# 获取背包中指定名称的物品列表，背包名称写死为"背包"
	var 物品列表 = GBIS.inventory_service.find_item_data_by_item_name("背包", 物品名称)
	var 总数量 = 0
	if 物品列表.size() == 0:
		return 0# 如果没有找到物品，直接返回0
	var 是可堆叠类型 = 物品列表[0] is StackableData# 只判断第一个物品的类型
	for 单个物品 in 物品列表:# 遍历所有找到的物品
		if 是可堆叠类型:# 可堆叠物品
			总数量 += 单个物品.current_amount
		else:# 不可堆叠物品，默认数量为1
			总数量 += 1
	return 总数量
func 获得资源(名称, 数量=0, 检查上限=true, 信号=true):# 增加或减少手工系统的资源数量
	if 数量==0:
		return
	var 手工 = 梅存档.get("手工", {})
	数量 = int(数量)  # 强制转换为整数
	if not 手工.has(名称):# 如果资源不存在，创建资源
		手工[名称] = 0
	var 当前数量 = 手工[名称]
	var 新数量 = 当前数量 + 数量
	var 溢出处理 = false  # 标记是否需要处理溢出
	var 溢出量 = 0.0  # 改为浮点数存储
	if 检查上限 and 名称 != "精华":# 检查上限逻辑，且资源不是精华时才执行
		# 建立资源名称与上限变量的映射关系
		var 上限变量名 = 名称 + "上限"
		# 检查当前资源是否有对应的上限设置
		var 上限值 = get(上限变量名)
		# 情况1：当前数量已超过上限，处理本次新增的全部数量作为溢出
		if 当前数量 > 上限值:
			溢出量 = 数量  # 本次新增的数量全部算作溢出
			溢出处理 = true
			新数量 = 当前数量  # 保持当前数量不变（已超上限）
		# 情况2：当前数量未超上限，但新增后超过上限
		elif 新数量 > 上限值:
			溢出量 = 新数量 - 上限值  # 计算超出上限的部分
			新数量 = 上限值  # 限制在最大值
			溢出处理 = true
	# 处理溢出资源转换为零件的逻辑（指定资源类型）
	if 溢出处理 and 名称 in ["木材", "矿石", "皮革", "药草"]:
		var 零件数量 = 溢出量 / 10.0  # 使用浮点数除法，保留小数
		if 零件数量 > 0:
			获得资源("零件", 零件数量, 检查上限, false)  # 递归调用自身
	if 新数量 <= 0:# 确保资源数量不会小于0
		手工[名称] = 0
	else:
		手工[名称] = 新数量  # 更新物品数量
	梅存档["手工"] = 手工# 更新数据但不直接存档
	if 信号:
		emit_signal("更新_UI")#调用UI更新信号
func 查看资源(名称 = "木材"):
	# 获取背包数据，不存在则创建空字典
	var 手工 = 梅存档.get("手工", {})
	# 检查物品是否存在并返回对应数量
	if 手工.has(名称):
		return 手工[名称]
	else:
		return 0
func 无功能方法():
	print("调用节点:", self.name)	
func 切换场景(子场景=null,主场景="合成界面"):
	# 检查"空节点"键是否存在于字典中
	if "空节点" in 节点 and 节点["空节点"] != null:
		# 存在则执行重载场景操作
		节点["空节点"].重载场景(主场景, 子场景)
	else:
		get_tree().change_scene_to_file("res://界面/空界面.tscn")
		print("空节点不存在，已切换到空界面")
func 结算升级(系统="手工",项目="null",跳过检查=false)-> int:
	var 数据 = 梅存档.get(系统,{"数据错误":0})
	if 数据 == {"数据错误":0}:
		print("未找到存档数据")
		return -1
	var 等级
	var 经验值
	var 基础
	var 成长 = 0.7
	var 倍率 = 0.5
	if 系统=="手工":#基础由系统类型决定.目前仅设计手工系统.
		基础 = 25
	else :
		基础 = 100
	if 项目=="null":#为空表示系统的升级检查,否则该值传入项目名称.例如 "基础剑" 与键名相同,经验值键名加精通后缀 例如"基础剑精通"
		等级 = int(数据.get("等级", 0))
		经验值 = int(数据.get("熟练", 0))
		成长 = 0.1
		倍率 = 5
	else:
		等级 = int(数据.get(项目, 0))
		经验值 = int(数据.get(项目+"精通", 0))
	if not 跳过检查:
		var 需求经验
		while true:#循环到等级为100或经验值不足,等级100时所需经验值为-1
			需求经验 = 精通熟练需求(等级,基础,成长,倍率)
			if 需求经验 > 0 and 经验值 >= 需求经验:
				等级 += 1
				经验值 -= 需求经验
			else:
				break
		if 项目=="null":#为空存回系统等级,反之同理
			数据["等级"]=等级
			数据["熟练"]=经验值
		else:
			数据[项目]=等级
			数据[项目+"精通"]=经验值
		梅存档[系统]=数据
		if 系统=="手工":
			初始化资源上限()
		return 需求经验
	return 精通熟练需求(等级,基础,成长,倍率)
func 精通收益(时间戳) -> int:
	if 时间戳==-1:
		return -1#特殊情况 之前的方法内报错会传入-1,同样返回-1
	var 一阶时长 = 60  # 1分钟（秒）# 收益时间限制变量
	var 二阶时长 = 300  # 5分钟（秒）
	var 当前时间 = Time.get_unix_time_from_system()# 获取当前时间戳
	var 时间差 = max(0, 当前时间 - 时间戳)# 计算时间差（确保不为负数）
	if 时间差 <= 一阶时长:# 根据时间差计算收益
		return int(时间差)
	elif 时间差 <= 二阶时长:
		return int(一阶时长+(时间差 - 一阶时长)/2.0)
	else:
		return int(一阶时长 + (二阶时长/2.0))
func 预生成文本(配方编号,配方解锁=false):
	var 表格字典 = 梅表格.获取表格字典(梅表格.装备蓝图, 配方编号)# 获取配方字典
	var 配方名称 = 表格字典.get("名称")
	var 配方等级 = 梅存档.get("手工",{}).get(配方名称, 0)
	if 表格字典 == {}:
		return"无效配方"
	var 属性对照 = {
		"攻击": "攻击",
		"血量": "血量",
		"耐久": "耐久"}
	# 构建内容字符串
	var 材料列表 = []
	for 键 in 材料对照:
		if 表格字典.has(键) and 表格字典[键] > 0:
			材料列表.append(材料对照[键] + "*" + str(表格字典[键]))
	var 内容字符串 = "费用:" + ("+".join(材料列表) if 材料列表.size() > 0 else "无")
	if 配方解锁:
		var 缓存字符串
		if 配方等级>0:
			缓存字符串="LV:"+str(配方等级)+" ("+str(梅存档.get("手工",{}).get(配方名称+"精通", 0))+"/"+str(结算升级("手工",配方名称,true))+")\r"
		else :
			缓存字符串="装备未解锁\r"
		内容字符串=缓存字符串+内容字符串
	else :
		内容字符串=表格字典["简介"]+"\r"+内容字符串
	var 属性列表 = []# 构建属性字符串
	for 键 in 属性对照:
		if 表格字典.has(键) and 表格字典[键] > 0:
			属性列表.append(属性对照[键] + ":" + str(表格字典[键]))
	var 属性字符串 = "\n".join(属性列表) if 属性列表.size() > 0 else ""
	return"配方:<" + 配方名称 + ">\n" + 内容字符串 + (("\n" + 属性字符串) if 属性字符串 != "" else "")
func 处理时间戳(时间戳名称: String) :
	var 当前时间:int = int(Time.get_unix_time_from_system())  # 获取当前系统时间戳（秒）
	if not 时间戳字典.has(时间戳名称):# 检查时间戳字典是否存在该键
		时间戳字典[时间戳名称] = 当前时间#不存在则创建并初始化为当前时间
	else:
		if 时间戳字典[时间戳名称] > 当前时间:# 处理系统时间回拨
			时间戳字典[时间戳名称] = 当前时间
	return 当前时间-时间戳字典[时间戳名称]
func 创建计时器(时间间隔: float, 回调方法: Callable, 是否循环: bool = true, 回传计时器: bool = false) -> Timer:
	var 计时器 = Timer.new()
	if 回传计时器:# 回传计时器：调用回调时传入计时器节点作为参数
		回调方法 = func():回调方法.call(计时器)  #回传计时器为true时，回调方法必须接受至少1个参数（Timer类型）
	计时器.wait_time = 时间间隔  # 设置间隔时间
	if 是否循环:# 默认
		计时器.timeout.connect(回调方法)  # 直接连接回调
	else:# 单次模式：触发一次后销毁计时器
		计时器.one_shot = true  # 仅触发一次
		计时器.timeout.connect(func():
			回调方法.call()  # 执行用户传入的回调
			计时器.queue_free())  # 销毁计时器（安全释放节点）
	add_child(计时器)  # 添加到节点树
	计时器.start()  # 启动计时器
	return 计时器
func 体力门票(需求体力值,门票名称=null) -> bool:
	var 挂机数据 = 初始化.梅存档["挂机"]
	var 门票=挂机数据.get("门票",{})
	if 需求体力值==0 and not 门票名称==null:
		if 门票.has(门票名称):#体力值设为0且门票不为null时为剪票逻辑,存在则返回成功并销毁门票.
			门票.erase(门票名称)
			return true
		return false
	if 门票名称 != null and 门票.has(门票名称) :
		return true
	elif 需求体力值<=挂机数据.get("体力值", 240):
		if 门票名称 != null:
			门票[门票名称]=int(Time.get_unix_time_from_system())
			挂机数据["门票"] = 门票
			引擎.屏幕.滚动提示("门票购买成功,今日内重试不反复消耗体力","门票")
		挂机数据["体力值"] -= 需求体力值
		保存存档()
		return true
	return false
func 获取零点时间戳(检查跳跃: int = 0,时间戳:int=int(Time.get_unix_time_from_system())) -> int:
	# 转换为北京时间戳（UTC+8）
	var 北京时间: int = int(检查跳跃+时间戳 + 32 * 3600)
	# 计算今天0点的北京时间戳
	var 目标零点: int= int(北京时间 / 86400.0) * 86400
	# 计算当前到初始目标零点的剩余秒数
	return 目标零点- 8 * 3600
#endregion 便利引用
#region 语法糖
func 语法糖获得物品(物品名称, 数量=1,  类型="标准物品",_参数 = null):
	获得物品语法糖(物品名称,数量,类型,_参数)#新代码规范 需要已语法糖开头 便利检索.原方法放入便利引用
func 语法糖消耗物品(物品名称, 数量=1,_参数 = null):
	GBIS.inventory_service.消耗指定数量物品("背包",物品名称,数量)
func 语法糖_快速熟练精通(时间戳名,系统,项目=null,熟练收益=true):
	var 时间戳=时间戳字典.get(时间戳名,-1)
	var 收益 = 精通收益(时间戳)
	if not 收益 > 0:
		print("精通熟练收益为:",str(收益),"\r#错误 获取量为0或负数.来自",系统,"系统.时间戳名称:",时间戳名)
		return
	var 数据 = 梅存档.get(系统,{})
	if 熟练收益:
		var 熟练= 数据.get("熟练",0)+收益
		var 精通= 数据.get("精通",0)+int(收益/2.0)
		梅存档[系统]["熟练"]=熟练
		梅存档[系统]["精通"]=精通
		引擎.屏幕.滚动提示(系统+"系统熟练+"+str(收益)+"精通池(+"+str(int(收益/2.0))+")","手工熟练")
		结算升级(系统)
	if 项目!=null:
		var 项目名= str(项目+"精通")
		var 精通= 数据.get(项目名,0)+收益
		梅存档[系统][项目名]=精通
		引擎.屏幕.滚动提示(项目名+"+"+str(收益),"手工精通")
		结算升级(系统,项目)
	var 当前时间 = Time.get_unix_time_from_system()# 获取当前时间戳
	时间戳字典[时间戳名] = int(当前时间)#更新时间戳
	#print_debug ("收益:",收益,"\r存档:",梅存档,"\r")
	保存存档()
#endregion 语法糖

func 语法备忘录(真: bool=true,假: bool=false,
整数: int = 1,浮点数: float = 1.0,文本:String = "",
数组: Array = [],字典: Dictionary = {},节点引用: Control = $Control,
颜色: Color = Color(1, 0, 0),空值 = null,
二维向量: Vector2 = Vector2(0,0),二维向量整数: Vector2i = Vector2i(0,0),
三维向量: Vector3 = Vector3(0,0,0),三维向量整数: Vector3i = Vector3i(0,0,0)):
	return[真,假,整数,浮点数,文本,数组,字典,节点引用,颜色,空值,二维向量,二维向量整数,三维向量,三维向量整数]
#func _process(_delta):#每帧执行
	#print()
	#emit_signal("更新_UI")#信号示例
