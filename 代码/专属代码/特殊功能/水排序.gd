extends Control

# 瓶子属性定义
@export var 内容长度: int = 4
@export var 内容数组: Array[Dictionary] = [{Color(1.0, 0.0, 0.0, 1.0): 1}]
var 隐藏条件颜色=[]
var 隐藏条件颜色数量=[]
var 隐藏元素数量:int=0
var 隐藏空瓶子=0
var 瓶子缩放=1
var 固定文本="消耗12体力开启关卡挑战,难度越大奖励越丰富
[img=40x30]res://素材/游戏素材/货币/without background/17.png[/img]本关卡门票0点过期
难度0:[url=1]颜料罐[/url]*4
难度1:[url=2]颜料罐[/url]*8,新增更多颜色.
难度2:[url=3]颜料罐[/url]*12,颜料罐扩容.
难度3:[url=4]颜料罐[/url]*16+8,隐藏颜料罐箱.
难度4:[url=5]颜料罐[/url]*21+9,颜料迷雾机制.
难度2_挑战1:超级扩容[url=6]颜料罐[/url]*8.
难度3_挑战2:[url=7]颜料罐[/url]*25+100,超级颜料罐箱.
难度4_挑战3:迷雾[url=8]颜料罐[/url]*24"
var 二次确认=0
var 固定图片="]点击确认[img=35x60]res://素材/豆包AI素材/像素瓶子.png[/img]["
var 颜料罐数组=[
	Color(1.0, 0.2, 0.2, 1.0),       # 亮红色
	Color(0.2, 0.8, 0.2, 1.0),        # 亮绿色
	Color(0.2, 0.2, 1.0, 1.0),        # 亮蓝色
	Color(1.0, 0.6, 0.0, 1.0),        # 橙色
	Color(1.0, 1.0, 0.2, 1.0),        # 亮黄色
	Color(0.8, 0.2, 0.8, 1.0),        # 紫色
	Color(1.0, 0.6, 0.8, 1.0),        # 粉红色
	Color(0.2, 0.8, 0.8, 1.0),        # 青绿色
	Color(0.6, 0.3, 0.1, 1.0),        # 棕色
	Color(0.9, 0.7, 0.4, 1.0),        # 浅棕色
	Color(0.5, 0.5, 0.5, 1.0),        # 中灰色
	Color(0.2, 0.2, 0.2, 1.0),        # 深灰色
	Color(0.9, 0.9, 0.7, 1.0),        # 米色
	Color(0.0, 0.5, 0.2, 1.0),        # 深绿色
	Color(0.0, 0.2, 0.6, 1.0),        # 深蓝色
	Color(0.6, 0.0, 0.3, 1.0),        # 深红色
	Color(0.4, 0.0, 0.6, 1.0),        # 深紫色
	Color(0.7, 0.9, 0.7, 1.0),        # 浅绿色
	Color(0.7, 0.7, 0.9, 1.0),]        # 浅蓝色
var 初始空瓶子数: int = 0
# 游戏变量
var 瓶子: Array[Control] = []
var 颜料池: Array[Color] = []
var 选中=null
var 奖励结算关卡
@onready var 瓶子碎片 = preload("res://粒子/瓶子碎片.tscn")
var 瓶子位置
func _ready():
# 游戏初始化：循环批量绑定1-5关的测试按钮
	for 关卡数 in range(1, 9):
		var 按钮节点 = get_node("%测试按钮" + str(关卡数))
		按钮节点.pressed.connect(func(): 初始化关卡(关卡数))
	%主菜单.pressed.connect(func(): 初始化.切换场景(null,"小游戏界面"))
	瓶子位置 = %瓶子位置
	%关卡.text="水排序"
	%隐藏瓶子数量.visible=false
	%关卡内容.visible=true
	%关卡内容.text=固定文本
	%"关卡容器".visible=true
	%"关卡内容".meta_clicked.connect(func(字):构建新文本(字))
func 初始化关卡(关卡: int):
	if not 初始化.体力门票(12,"水排序"):
		引擎.屏幕.滚动提示("体力不足","小游戏")
		return
	%"关卡容器".visible=false
	清空瓶子()# 清空现有瓶子
	var 颜色数组: Array[Dictionary]
	隐藏条件颜色=[]
	隐藏元素数量=0
	内容长度 = 4
	瓶子缩放=2
	var 迷雾瓶子数量=0
	奖励结算关卡=关卡
	if 关卡<=5:
		%关卡.text="第"+["一", "二", "三", "四", "五"][关卡-1] + "关"
	if 关卡 == 1:# 根据关卡设置参数
		颜色数组 = 生成颜料数组([2,1,1])
	elif  关卡==2:
		颜色数组 = 生成颜料数组([2,2,2,2])
	elif  关卡==3:
		瓶子缩放=1.5
		内容长度 = 5
		颜色数组 = 生成颜料数组([3,3,2,2,2])
	elif 关卡 == 4:
		瓶子缩放=1.5
		内容长度 = 6
		颜色数组 = 生成颜料数组([4,4,4,4,4,4])
		隐藏元素数量=8
		构建隐藏元素任务(颜色数组,3)
	elif 关卡 == 5:
		瓶子缩放=1.25
		内容长度 = 6
		颜色数组 = 生成颜料数组([2,4,4,4,4,4,4,4],3)
		隐藏元素数量=10
		迷雾瓶子数量=10
		构建隐藏元素任务(颜色数组,3)
	elif 关卡 == 6:
		瓶子缩放=4
		%关卡.text="挑战一"
		奖励结算关卡=3
		内容长度 = 25
		颜色数组 = 生成颜料数组([2,3,3])
	elif 关卡 == 7:
		瓶子缩放=1
		%关卡.text="挑战二"
		奖励结算关卡=4
		内容长度 = 3
		颜色数组 = 生成颜料数组([25,25,25,25,25])
		隐藏元素数量=100
		隐藏空瓶子=1
		构建隐藏元素任务(颜色数组,5)
	elif 关卡 == 8:
		瓶子缩放=1.25
		%关卡.text="挑战三"
		奖励结算关卡=5
		内容长度 = 10
		颜色数组 = 生成颜料数组([5,5,5,5,5],2)
		迷雾瓶子数量=25
	重新计算瓶子间距()
	%关卡内容.visible=false
	%隐藏瓶子数量.text="消除指定颜色\r显示隐藏瓶子\r瓶子数量:"+str(隐藏元素数量+隐藏空瓶子)
	if 隐藏元素数量==0:
		%隐藏瓶子数量.visible=false
	else :
		%隐藏瓶子数量.visible=true
	# 构建颜料池
	构建颜料池(颜色数组)
	# 生成瓶子
	生成瓶子(颜色数组)
	处理瓶子状态(瓶子,隐藏元素数量,迷雾瓶子数量,隐藏空瓶子)
func 构建新文本(关卡):
	if 二次确认==int(关卡):
		初始化关卡(int(关卡))
		return
	二次确认=int(关卡)
	%关卡内容.text=替换关键词(固定文本,"]颜料罐[",固定图片,int(关卡))
	print("点击值：", 关卡)
	pass
func 查找位置(文本: String, 关键词: String, n: int) -> int:
	if n <= 0:
		print("错误：n必须是正整数（n>0）")
		return -1
	var 关键词长度 = 关键词.length()
	if 关键词长度 == 0:
		print("错误：关键词不能为空")
		return -1
	var 当前位置 = 0  # 每次查找的起始位置
	var 找到次数 = 0  # 已找到的次数
	while 找到次数 < n:
		# 从当前位置开始查找关键词
		var 出现位置 = 文本.find(关键词, 当前位置)
		if 出现位置 == -1:
			# 没找到足够的次数，返回-1
			return -1
		# 找到一次，累加计数
		找到次数 += 1
		# 下一次查找从当前出现位置的结束处开始（避免重复匹配）
		当前位置 = 出现位置 + 关键词长度
	# 循环结束时，最后一次找到的位置就是第n次出现的位置
	return 当前位置 - 关键词长度
func 替换关键词(原文本: String, 关键词: String, 替换内容: String, n: int) -> String:
	# 查找第n次出现的位置
	var 第n次位置 = 查找位置(原文本, 关键词, n)
	print(原文本)
	if 第n次位置 == -1:
		print("未找到第", n, "次出现的'"+关键词+"'，返回原文本")
		return 原文本  # 未找到，返回原文本
	# 执行替换：拼接前半部分 + 替换内容 + 后半部分
	print(原文本.substr(0, 第n次位置))
	print(替换内容)
	print(原文本.substr(第n次位置 + 关键词.length()))
	var 修改后文本 = 原文本.substr(0, 第n次位置) + 替换内容 + 原文本.substr(第n次位置 + 关键词.length())
	return 修改后文本

func 构建隐藏元素任务(颜色数组, 数量):
	# 清空之前的结果，避免累积
	隐藏条件颜色数量.clear()
	# 1. 过滤非空瓶子元素 → 2. 提取每个字典的键和值 → 3. 复制并打乱 → 4. 取前指定数量
	var 有效颜色键值对 = 颜色数组.filter(func(elem): 
		return "空瓶子" not in elem
	).map(func(elem):
		var 键 = elem.keys()[0]  # 获取唯一键
		var 值 = elem[键]        # 获取对应值
		return [键, 值]          # 返回键值对数组
	)
	有效颜色键值对 = 有效颜色键值对.duplicate()  # 复制数组避免修改原数据
	有效颜色键值对.shuffle()                     # 打乱顺序
	# 取前指定数量的键值对，并分别存储
	for i in range(min(数量, 有效颜色键值对.size())):
		隐藏条件颜色.append(有效颜色键值对[i][0])  # 存储键
		隐藏条件颜色数量.append(有效颜色键值对[i][1])  # 存储对应值
func 构建颜料池(颜色数组: Array[Dictionary]):
	颜料池.clear()
	for 颜色项 in 颜色数组:
		# 跳过空瓶子
		if "空瓶子" in 颜色项:
			初始空瓶子数 = 颜色项["空瓶子"]
			continue
		# 获取颜色和瓶子数量
		var 颜色 = 颜色项.keys()[0]
		var 瓶子数量 = 颜色项[颜色]
		# 添加对应数量的颜料到颜料池
		for i in range(瓶子数量 * 内容长度):
			颜料池.append(颜色)
	颜料池.shuffle()# 打乱颜料池
func 重新计算瓶子间距():
	# 实例化瓶子场景并计算宽度
	var 瓶子场景 = preload("res://界面/插件/瓶子.tscn").instantiate()
	var 瓶子宽度 = 瓶子场景.custom_minimum_size.x * 瓶子缩放
	var 父容器宽度 = 1380
	var 默认间距 = 80  # 数量>10时的默认间距
	
	# 特殊情况：单个瓶子宽度超过父容器宽度
	if 瓶子宽度 > 父容器宽度:
		瓶子位置.columns = 1
		# 正确设置水平间距：使用add_theme_constant_override
		瓶子位置.add_theme_constant_override("h_separation", 0)
		print("单个瓶子宽度超过容器，设置为1列，间距0")
		return
	
	# 初始计算能容纳的数量
	var 元素数量 = floor(父容器宽度 / (瓶子宽度+默认间距))
	
	# 情况1：初始数量大于10，固定为10列，使用默认间距
	if 元素数量 > 10:
		瓶子位置.columns = 10
		瓶子位置.add_theme_constant_override("h_separation", 默认间距)
		print("元素数量超过10，设置为10列，默认间距80")
	# 情况2：初始数量小于10，尝试优化布局
	else:
		# 尝试放下10个瓶子：计算所需最小间距
		var 十个瓶子总宽度 = 10 * 瓶子宽度
		var 可用间距空间 = 父容器宽度 - 十个瓶子总宽度
		# 如果可用空间足够放下10个（即使间距为0）
		if 可用间距空间 >= 0:
			瓶子位置.columns = 10
			# 计算间距（平均分配可用空间，至少为0）
			var 实际间距 = 可用间距空间 / (10 - 1) if 10 > 1 else 0
			瓶子位置.add_theme_constant_override("h_separation", max(0, 实际间距))
		# 空间不足，需要减少元素数量
		else:
			# 从9开始递减尝试，找到能放下的最大数量
			var 最佳数量 = 9
			while 最佳数量 > 0:
				var 总宽度需求 = 最佳数量 * 瓶子宽度
				var 所需间距空间 = 父容器宽度 - 总宽度需求
				# 找到第一个能放下的数量
				if 所需间距空间 >= 0:
					瓶子位置.columns = 最佳数量
					var 实际间距 = 所需间距空间 / (最佳数量 - 1) if 最佳数量 > 1 else 0
					瓶子位置.add_theme_constant_override("h_separation", max(0, 实际间距))
					break
				
				最佳数量 -= 1
func 生成瓶子(颜色数组: Array[Dictionary]):
	var 总瓶子数 = 0# 计算总瓶子数量
	for 颜色项 in 颜色数组:
		总瓶子数 += 颜色项.values()[0]
	# 加载瓶子场景
	var 瓶子场景 = preload("res://界面/插件/瓶子.tscn").instantiate()
	# 生成每个瓶子
	for i in range(总瓶子数):
		# 克隆瓶子节点
		var 新瓶子 = 瓶子场景.duplicate()
		# 计算当前瓶子应包含的颜料
		var 起始索引 = i * 内容长度
		var 结束索引 = 起始索引 + 内容长度
		var 当前颜料 = 颜料池.slice(起始索引, 结束索引)
		# 构建内容数组
		var 瓶子内容: Array[Dictionary] = []
		for 颜色 in 当前颜料:
			瓶子内容.append({颜色: 1})
		# 设置瓶子属性
		var 瓶子缩放节点 = 新瓶子.get_node_or_null("瓶子缩放")
		if 瓶子缩放节点 is Control:
			瓶子缩放节点.scale = Vector2(瓶子缩放, 瓶子缩放)
			新瓶子.custom_minimum_size = 新瓶子.custom_minimum_size * 瓶子缩放
		新瓶子.内容长度 = 内容长度
		新瓶子.内容数组 = 瓶子内容
		新瓶子.更新瓶子()
		新瓶子.gui_input.connect(func(按键信号): 
			if 按键信号 is InputEventMouseButton and 按键信号.pressed:
				瓶子点击(按键信号,i))
		# 添加到场景和数组
		瓶子位置.add_child(新瓶子)
		瓶子.append(新瓶子)
func 处理瓶子状态(所有瓶子: Array, 隐藏数量:int, 迷雾数量:int,隐藏空瓶子数量:int=0):
	# 1. 筛选非空瓶子（排除空瓶子）
	var 非空瓶子 = 所有瓶子.filter(func(瓶): 
		# 空瓶子的唯一特征是内容数组元素为0，因此非空瓶子即内容数组大小>0
		return 瓶.内容数组.size() > 0)
	if 隐藏空瓶子数量>0:
		var 空瓶子 = 所有瓶子.filter(func(瓶): 
			return 瓶.内容数组.size() == 0)
		for i in range(隐藏空瓶子数量):
			空瓶子[i].visible = false
	# 2. 处理隐藏瓶子
	if 隐藏数量 > 0 and 非空瓶子.size() > 0:
		var 待隐藏 = 非空瓶子.duplicate()
		待隐藏.shuffle()
		var 实际隐藏 = min(隐藏数量, 待隐藏.size())
		for i in range(实际隐藏):
			待隐藏[i].visible = false  # 隐藏逻辑（可替换为实际隐藏方法）
			# 可选：添加隐藏标记，如 待隐藏[i].is_hidden = true
	var 箱子场景 = preload("res://界面/插件/颜色罐箱.tscn").instantiate()
	for i in range(隐藏条件颜色.size()):
		var 新箱子 = 箱子场景.duplicate()
		var 子节点_颜色 = 新箱子.get_node("箱子")  # 明确获取子节点
		var 子节点_文本 = 新箱子.get_node("文本")
		子节点_颜色.color=隐藏条件颜色[i]
		子节点_文本.text=str(隐藏条件颜色数量[i])
		%"箱子位置".add_child(新箱子)
	# 3. 处理迷雾瓶子（包含已隐藏的非空瓶子）
	if 迷雾数量 > 0 and 非空瓶子.size() > 0:
		var 待迷雾 = 非空瓶子.duplicate()
		待迷雾.shuffle()
		var 实际迷雾 = min(迷雾数量, 待迷雾.size())
		for i in range(实际迷雾):
			待迷雾[i].迷雾(true)  # 执行迷雾方法
func 瓶子点击(按键信号,i):
	if 按键信号.button_index == MOUSE_BUTTON_LEFT:
		var 当前瓶子 = 瓶子[i]
		if 选中 == null:
			选中 = 当前瓶子
			当前瓶子.选中(false)
			print("当前瓶子\r",当前瓶子.内容数组)
		else:
			if 选中==当前瓶子:
				选中.选中(true)
				选中 = null
				return
			print("开始转移\r",当前瓶子.内容数组,"\r",选中.内容数组)
			# 选中瓶子 往 当前瓶子中 转移液体
			转移液体(选中, 当前瓶子)
			# 无论是否成功转移，都取消选中状态
			选中.选中(true)
			选中 = null
	elif 按键信号.button_index == MOUSE_BUTTON_RIGHT:
		pass
	else :
		pass
func 转移液体(来源瓶子, 本体瓶子):
	# 打印函数入口信息
	#print("\n===== 开始液体转移 =====")
	#print("来源瓶子: %s, 本体瓶子: %s" % [来源瓶子, 本体瓶子])
	# 检查本体瓶子是否有空间，且来源瓶子不是空的
	var 检查条件1 = 本体瓶子.内容数组.size() < 本体瓶子.内容长度 
	var 检查条件2 = 来源瓶子.内容数组.size() > 0
	#print("当前瓶子有空间: %s, 来源非空: %s" % [检查条件1, 检查条件2])
	if 检查条件1 and 检查条件2:
		# 获取本体瓶子顶部液体颜色
		var 来源顶部颜色 = 来源瓶子.内容数组[-1].keys()[0]
		#print("来源顶部颜色: %s" % 来源顶部颜色)
		var 颜色匹配=false
		# 检查顶部颜色相同,或本体为空
		if not 本体瓶子.内容数组==[]:
			颜色匹配 = 本体瓶子.内容数组[-1].keys()[0] == 来源顶部颜色
		#print("颜色是否匹配: %s" % [颜色匹配])
		if 本体瓶子.内容数组==[] or 颜色匹配:
			# 计算来源瓶子剩余空间
			var 剩余空间 = 本体瓶子.内容长度 - 本体瓶子.内容数组.size()
			#print("本体瓶子剩余空间: %s (总容量: %s, 当前数量: %s)" % [剩余空间, 本体瓶子.内容长度, 本体瓶子.内容数组.size()])
			
			# 计算来源瓶子中可转移的同色液体数量
			var 可转移数量 = 0
			#print("开始计算可转移数量，本体液体序列:")
			var 内容的数组=来源瓶子.内容数组.duplicate(true)
			内容的数组.reverse()
			for 液体 in 内容的数组:
				var 液体颜色 = 液体.keys()[0]
				#print("  检查液体: %s" % 液体颜色)
				if 液体颜色 == 来源顶部颜色:
					可转移数量 += 1
					#print("  颜色匹配，可转移数量更新为: %s" % 可转移数量)
				else:
					#print("  颜色不匹配，停止计数")
					break
			#print("计算完成，可转移数量: %s" % 可转移数量)
			# 实际转移数量是剩余空间和可转移数量中的较小值
			var 实际转移数量 = min(剩余空间, 可转移数量)
			#print("实际转移数量: %s (取剩余空间%s和可转移数量%s的最小值)" % [实际转移数量, 剩余空间, 可转移数量])
			# 执行转移
			for i in range(实际转移数量):
				# 从来源瓶子移除最后一个元素
				var 转移液 = 来源瓶子.内容数组[-1]
				来源瓶子.内容数组.pop_back()
				# 添加到来源瓶子
				本体瓶子.内容数组.append(转移液)
			来源瓶子.更新瓶子()
			本体瓶子.更新瓶子()
			# 打印转移后的状态
			#print("转移完成 - 本体剩余内容: %s" % [本体瓶子.内容数组])
			#print("转移完成 - 目标当前内容: %s" % [来源瓶子.内容数组])
			# 检查是否有瓶子已经装满同一种颜色
			#print("开始检查完成的瓶子...")
			检查完成的瓶子(本体瓶子)
		else:
			#print("转移失败: 来源瓶子不为空且颜色不匹配")
			pass
	else:
		pass
		#print("转移失败: 来源瓶子无空间或本体瓶子为空")
	#print("===== 液体转移结束 =====\n")


			
func 检查完成的瓶子(瓶):
	# 检查瓶子是否已满且所有液体颜色相同
	if 瓶.内容数组.size() == 瓶.内容长度:
		var 颜色 = 瓶.内容数组[0].keys()[0]
		var 所有颜色相同 = true
		var 目标颜色
		for 液体 in 瓶.内容数组:
			目标颜色 = 液体.keys()[0]
			if 液体.keys()[0] != 颜色:
				所有颜色相同 = false
				break
		if 所有颜色相同:
			var 当前剩余瓶子数 = 瓶子位置.get_child_count()
			if 当前剩余瓶子数 == 初始空瓶子数+1:
				游戏胜利()
			else :
				var 粒子效果 = 瓶子碎片.instantiate()
				%粒子容器.add_child(粒子效果)
				粒子效果.global_position=瓶.global_position
				粒子效果.restart()
				if 隐藏条件颜色.size()>0:
					隐藏条件(目标颜色)
				瓶.queue_free()
				await get_tree().create_timer(1.0).timeout
				粒子效果.queue_free()
func 游戏胜利():
	print("恭喜！游戏胜利！")
	%关卡内容.visible=true
	var 奖励
	if 初始化.体力门票(0,"水排序"):
		奖励="恭喜通关:完成难度"+str(["一", "二", "三", "四", "五"][奖励结算关卡-1])+",获得\r"+计算奖励()+"\r"
	%关卡内容.text=奖励+固定文本
	%"关卡容器".visible=true
	清空瓶子()
func 隐藏条件(目标颜色,显示数量:int=2):
	var 索引 = 隐藏条件颜色.find(目标颜色)
	if 索引 != -1:
		隐藏条件颜色数量[索引] -= 1# 对应位置的数量减1
		var 所有子节点 = %"箱子位置".get_children()
		显示隐藏瓶子(显示数量)
		if 隐藏条件颜色数量[索引] <= 0:# 检查是否小于等于0
			所有子节点[索引].queue_free()
			隐藏条件颜色.pop_at(索引)
			隐藏条件颜色数量.pop_at(索引)
		if 隐藏条件颜色.size()==0:
			显示隐藏瓶子(-1)
			%隐藏瓶子数量.visible=false
			for 子节点 in %"箱子位置".get_children().duplicate():
				if 子节点 is Control:  # 确保是箱子节点
					子节点.queue_free()
		else :
			所有子节点[索引].文本.text=str(隐藏条件颜色数量[索引])
func 计算奖励() -> String:
	var X=奖励结算关卡
	# 1. 初始化基础奖励（金币）
	var 奖励字典 = {"金币": X * 250 + 1000}  # 基础金币公式
	# 2. 定义小游戏奖池（包含各奖励的计算方式）
	var 小游戏奖池 = [
		{"名称": "蓝图纸","数量公式": func(): return 3 ** min(3, X) * 10 + 20},
		{"名称": "金币","数量公式": func(): return 3 ** min(5, X) * 250},
		{"名称": "绿色电路板","数量公式": func(): return 1*X+5}]
	# 3. 执行X次额外抽取
	for i in range(X):
		# 随机抽取一个奖池内容
		var 随机索引 = randi() % 小游戏奖池.size()
		var 抽取的奖励 = 小游戏奖池[随机索引]
		# 计算本次奖励数量
		var 本次数量 = 抽取的奖励.数量公式.call()
		# 添加到奖励字典（已存在则累加）
		if 奖励字典.has(抽取的奖励.名称):
			奖励字典[抽取的奖励.名称] += 本次数量
		else:
			奖励字典[抽取的奖励.名称] = 本次数量
	# 4. 格式化奖励文本（例如："金币: 1250, 蓝图纸: 50"）
	var 奖励文本 = ""
	for 奖励名称 in 奖励字典:
		奖励文本 += "%s: %s, " % [奖励名称, 奖励字典[奖励名称]]
		if 奖励名称=="金币":
			初始化.梅存档["金币"]+=奖励字典[奖励名称]
		else :
			初始化.语法糖获得物品(奖励名称,奖励字典[奖励名称])
	# 移除末尾多余的逗号和空格
	if 奖励文本.length() > 0:
		奖励文本 = 奖励文本.substr(0, 奖励文本.length() - 2)
		初始化.保存存档()
	return 奖励文本
func 清空瓶子():
	# 直接从容器节点获取并移除所有子节点
	if 瓶子位置:
		# 遍历所有子节点的副本（避免迭代中修改集合）
		for 子节点 in 瓶子位置.get_children().duplicate():
			if 子节点 is Control:  # 确保是瓶子节点
				子节点.queue_free()
	if %"箱子位置":
		# 遍历所有子节点的副本（避免迭代中修改集合）
		for 子节点 in %"箱子位置".get_children().duplicate():
			if 子节点 is Control:  # 确保是箱子节点
				子节点.queue_free()
	# 清空瓶子数组（保持数据一致性）
	瓶子.clear()
	隐藏条件颜色.clear()
	隐藏条件颜色数量.clear()
	print("已清空所有瓶子")
func 显示隐藏瓶子(显示数量:int) -> void:
	# 过滤出所有隐藏的瓶子（根据实际隐藏逻辑调整判断条件，如visible属性）
	var 隐藏的瓶子 = 瓶子位置.get_children().filter(func(瓶):
		return not 瓶.visible)  # 假设隐藏状态为 visible = false
	var 剩余未显示数量 = 隐藏的瓶子.size()
	if 显示数量==-1:
		显示数量=剩余未显示数量
	隐藏元素数量=max(0,剩余未显示数量-显示数量)
	%隐藏瓶子数量.text="消除指定颜色\r显示隐藏瓶子\r瓶子数量:"+str(隐藏元素数量)
	if 隐藏元素数量==0:
		%隐藏瓶子数量.visible=false
	# 无隐藏瓶子或参数无效时，直接返回
	if 剩余未显示数量 == 0 or 显示数量 <= 0:
		return
	# 确定实际要显示的数量：取参数和剩余数量中的较小值
	var 实际显示数量 = min(显示数量, 剩余未显示数量)
	# 按顺序显示指定数量的隐藏瓶子（从第一个隐藏的开始）
	for i in range(实际显示数量):
		隐藏的瓶子[i].visible = true  # 设置为显示
func 生成颜料数组(瓶子数量数组: Array, 空瓶子数量: int=2) -> Array:
	# 第一步：处理瓶子数量数组，确保不超过颜料罐数组长度
	var 调整后的数量= []
	var 最大长度 = 颜料罐数组.size()
	for i in range(min(瓶子数量数组.size(), 最大长度)):
		调整后的数量.append(瓶子数量数组[i])
	
	# 第二步：打乱颜色数组顺序，红绿蓝排最前面
	# 分离出红、绿、蓝三种颜色（根据颜料罐数组中的索引）
	var 红色 = 颜料罐数组[0]
	var 绿色 = 颜料罐数组[1]
	var 蓝色 = 颜料罐数组[2]
	
	# 剩余颜色（排除前三个）
	var 其他颜色 = 颜料罐数组.duplicate()
	其他颜色.erase(红色)
	其他颜色.erase(绿色)
	其他颜色.erase(蓝色)
	
	# 打乱剩余颜色顺序
	其他颜色.shuffle()
	
	# 组合新的颜色顺序：红绿蓝 + 打乱的其他颜色
	var 打乱后的颜色 = [红色, 绿色, 蓝色] + 其他颜色
	
	# 第三步：创建结果数组
	var 结果数组: Array[Dictionary] = []
	for i in range(调整后的数量.size()):
		# 创建颜色-数量字典
		var 颜色字典 = {}
		颜色字典[打乱后的颜色[i]] = 调整后的数量[i]
		结果数组.append(颜色字典)
	
	# 添加空瓶子到末尾
	结果数组.append({"空瓶子": 空瓶子数量})
	
	return 结果数组
