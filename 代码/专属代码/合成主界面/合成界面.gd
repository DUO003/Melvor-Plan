extends Control
var 资源每秒 = {"木材":1, "矿石":1, "皮革":1, "药草":1}
var 制作队列名称=[]
var 制作指针=0
var 进度动画播放中=false
# 存储最近一分钟内的帧间隔数据
var 帧率数据: Array[float] = []
# 累计最近一分钟的总时间（用于快速判断是否超过60秒）
var 总时间: float = 0.0
# 计算得到的一分钟平均帧率
var 平均帧率: float = 0.0

func _ready() -> void:
	#注册
	初始化.节点["合成界面"]=self
	#资源回复逻辑
	var 当前时间 = Time.get_unix_time_from_system ()
	var 离线时间 = 初始化.时间戳字典.get ("资源回复", 当前时间)
	if abs (当前时间 - 离线时间) > 10:
		if 当前时间>=离线时间:
			离线动作(当前时间 - 离线时间)
		初始化.时间戳字典["资源回复"] = int(当前时间)
	%动作进度条.开始动作("资源回复",1.0,self)
	初始化.connect("更新_UI", Callable(self, "_更新_UI"))
	#熟练度逻辑
	var 手工熟练时间戳 = 初始化.时间戳字典.get("手工熟练", 当前时间)
	初始化.时间戳字典["手工熟练"] = int(手工熟练时间戳)
	初始化.创建计时器(1.0, Callable(self, "更新信息"))# 封装计时器方法
	注册进度条()
	#加载后更新一次UI
	_更新_UI()
	更新信息()
	注册按钮()
func _process(delta: float) -> void:
	# 更新进度条
	if not 进度动画播放中:
		进度动画播放中=true
		更新制作队列进度条()
		# 1. 记录当前帧的间隔时间
	帧率数据.append(delta)
	总时间 += delta
	
	# 2. 移除超过1分钟（60秒）的旧数据
	while 总时间 > 60.0:
		var  oldest_delta = 帧率数据.pop_front()  # 移除最早的帧数据
		总时间 -= oldest_delta
	
	# 3. 计算平均帧率（总帧数 / 总时间）
	if 总时间 > 0:
		var 原始帧率 = 帧率数据.size() / 总时间
		平均帧率 = round(原始帧率 * 10) / 10  # 保留1位小数（精度0.1）
	else:
		平均帧率 = 0.0
	
	# （可选）打印或使用平均帧率
	# print("一分钟平均帧率: ", 平均帧率)

func 注册按钮():
	%派遣队.pressed.connect(初始化.无功能方法)
	%装备充能.pressed.connect(初始化.无功能方法)
	%抽奖机.pressed.connect(func(): 初始化.切换场景("合成_抽奖机界面"))
	%蓝图库.pressed.connect(初始化.无功能方法)
	print("按钮已注册")
	



func 更新信息():
	#print ("更新信息触发")
	var 熟练值 = 初始化.精通收益(初始化.时间戳字典.get("手工熟练",-1))
	%提示文本.text="暂存熟练\r"+str(熟练值)+"\rfps:"+str(平均帧率)
	pass

func 注册进度条():
	var 制造队列 = %圆形进度条
	制作指针=0
	%圆形进度条.visible = false
	if 制造队列:
		for i in range(6):
			var 克隆节点
			var 制作队列配方按钮节点
			if 制作队列名称.size()==6:
				克隆节点 = 制作队列名称[i]
				制作队列配方按钮节点 = 克隆节点.get_node("配方")
			else:
				克隆节点 = 制造队列.duplicate()
				制作队列配方按钮节点 = 克隆节点.get_node("配方")
				%制作队列.add_child(克隆节点)
				制作队列名称.append(克隆节点)
				克隆节点.name = "制作队列" + str(i + 1)  # 命名为配方1、配方2...
				克隆节点.visible = true  # 克隆节点设为可见
				克隆节点.更新进度(0.0)
				制作队列配方按钮节点.gui_input.connect(func(按键信号): 
					if 按键信号 is InputEventMouseButton and 按键信号.pressed:
						制作队列更新(按键信号,i))
			var 图片路径 = ""
			var 制作队列配方名节点 = 制作队列配方按钮节点.get_node("配方名")
			var 制作队列 = 初始化.梅存档.get("手工",{}).get("制作队列", [])
			if i < 制作队列.size():
				var 配方的名称=制作队列[i]
				图片路径 = 梅表格.获取表格信息(梅表格.装备蓝图,配方的名称,"icon")
				克隆节点.配方序号 = 梅表格.获取表格信息(梅表格.装备蓝图,配方的名称,"名称")
				print("配方名: ", 配方的名称)
				print("配方序号: ", str(克隆节点.配方序号))
				制作队列配方名节点.text=配方的名称
			else :
				克隆节点.配方序号 = null
				制作队列配方名节点.text=""
			var 制作队列贴图节点 = 制作队列配方按钮节点.get_node("配方贴图")
			if 图片路径 != "":
				var 纹理 = load(图片路径)
				if 纹理 != null:
					制作队列贴图节点.texture = 纹理
			else:
				if not 克隆节点.配方序号 == null:
					print("无法加载图片: ", 图片路径)
				制作队列贴图节点.texture = null

func _更新_UI():
	更新信息()
	# 定义资源名称与对应进度条节点唯一名称的映射
	var 资源映射 = [
		{"名称": "矿石", "节点名": "%矿石进度"},
		{"名称": "木材", "节点名": "%木材进度"},
		{"名称": "皮革", "节点名": "%皮革进度"},
		{"名称": "药草", "节点名": "%药草进度"},
		{"名称": "零件", "节点名": "%零件进度"},
		{"名称": "精华", "节点名": "%精华进度"}]
	# 循环处理每个资源的UI更新
	for 资源 in 资源映射:
		# 先验证资源数据是否有效
		if 资源 == null or not 资源.has("节点名") or not 资源.has("名称"):
			print("无效的资源配置数据: ", 资源)
			continue
		# 获取节点唯一名称
		var 节点名 = 资源["节点名"]
		if 节点名 == "":
			print("资源 '", 资源["名称"], "' 的节点名为空")
			continue
		# 查找节点
		var 进度条 = get_node_or_null(str(节点名))
		# 验证节点是否存在且类型正确
		if 进度条 == null:
			print("找不到节点，唯一名称: ", 节点名)
			continue
		if not 进度条 is ProgressBar:
			print("唯一名称 '", 节点名, "' 对应的不是ProgressBar节点")
			continue
		# 节点验证通过，更新进度条
		if 资源["名称"] == "精华":
			进度条.max_value = 1
			进度条.value = 1
		else:
			var 当前数量 = 初始化.查看资源(资源["名称"])
			var 上限变量名 = 资源["名称"] + "上限"
			var 上限值 = 初始化.get(上限变量名)
			进度条.max_value = 上限值
			进度条.value = 当前数量

func 处理动作():
	# 获取当前时间和离线时间
	var 当前时间 = Time.get_unix_time_from_system()
	var 离线时间 = 初始化.时间戳字典.get("资源回复", 当前时间)
	var 进度条时长 = max(1, 当前时间 - 离线时间)  # 确保至少1秒
	# 更新时间戳
	初始化.时间戳字典["资源回复"] = int(当前时间)
	var 资源列表 = ["木材", "矿石", "皮革", "药草"]
	var 总增加量 = {
		"木材": 0.0,
		"矿石": 0.0,
		"皮革": 0.0,
		"药草": 0.0
	}
	# 计算需要处理的时间段
	var 处理时间段 = []
	if 进度条时长 > 10:
		var 完整循环次数 = floor(进度条时长 / 10)
		var 剩余秒数 = 进度条时长 - 10 * 完整循环次数
		for i in range(完整循环次数):
			处理时间段.append(10)# 添加完整的10秒时间段
		if 剩余秒数 > 0:
			处理时间段.append(剩余秒数)# 添加剩余秒数
	else:
		处理时间段.append(进度条时长)
	# 循环处理所有时间段，累加资源增加量
	for 时长 in 处理时间段:
		var 基础量 = {}
		for 资源名 in 资源列表:
			基础量[资源名] = 资源每秒.get(资源名, 0.0) * 时长
		# 累加各资源增加量
		总增加量["木材"] += 基础量["木材"] * 1.0  # 木材：必然增加1倍
		# 矿石：50%概率增加2倍，否则不增加
		if randf() < 0.5:
			总增加量["矿石"] += 基础量["矿石"] * 2.0
		# 皮革：25%~175%随机量
		总增加量["皮革"] += 基础量["皮革"] * randf_range(0.25, 1.75)
		# 药草：80%概率增加，25%~218.75%随机量
		if randf() < 0.8:
			总增加量["药草"] += 基础量["药草"] * randf_range(0.25, 2.1875)
	
	# 一次性调用获得资源方法
	初始化.获得资源("木材", 总增加量["木材"], true, false)
	初始化.获得资源("矿石", 总增加量["矿石"], true, false)
	初始化.获得资源("皮革", 总增加量["皮革"], true, false)
	初始化.获得资源("药草", 总增加量["药草"], true, false)
	# 触发UI更新和保存
	初始化.emit_signal("更新_UI")
	初始化.保存存档()
	
func 离线动作(进度条时长 = 1.0):
	print ("离线动作触发")
	var 资源列表 = ["木材", "矿石", "皮革", "药草"]
	var 基础量 = {}
	for 资源名 in 资源列表:
		基础量[资源名] = 资源每秒.get(资源名, 0.0) * 进度条时长
	var 木材增加 = 基础量["木材"]
	var 矿石增加 = 基础量["矿石"]
	var 皮革增加 = 基础量["皮革"]
	var 药草增加 = 基础量["药草"]
	初始化.获得资源("木材", 木材增加, true, false)
	初始化.获得资源("矿石", 矿石增加, true, false)
	初始化.获得资源("皮革", 皮革增加, true, false)
	初始化.获得资源("药草", 药草增加, true, false)
	# 统一触发UI更新
	初始化.emit_signal("更新_UI")

func 更新制作队列进度条():
	# 检查队列是否为空或所有节点配方序号都是null（视为空队列）
	var 存在有效配方 = false
	for 节点 in 制作队列名称:
		if 节点 != null and 节点.配方序号 != null:
			存在有效配方 = true
			break
	if not 存在有效配方:
		for i in range(制作队列名称.size()):# 循环处理队列中所有节点的进度条
			制作队列名称[i].更新进度(-1)
		进度动画播放中=false
		return
	var 检查节点 = 制作队列名称[制作指针]
	if 检查节点 == null or 检查节点.配方序号 == null:
		制作指针 = 0# 处理当前指针节点变为null的情况（如玩家取消）
	var 当前进度 = 0.0# 存储检查节点的进度值
	var 当前节点
	for i in range(制作队列名称.size()):# 循环处理队列中所有节点的进度条
		当前节点 = 制作队列名称[i]
		if i == 制作指针:
			# 仅在检查节点调用一次制作方法并存储结果
			当前进度 = %配方表格.制作物品(当前节点.配方序号)
		else:
			# 非检查节点进度设为
			当前节点.更新进度(-1)
	# 结束时根据存储的进度值判断是否移动指针
	当前节点 = 制作队列名称[制作指针]
	var 补间实例 = create_tween()
	补间实例.tween_method(
		func(中间值: float):
			当前节点.更新进度(中间值),当前节点.进度,当前进度,1).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_QUAD)
	await 补间实例.finished
	if 当前进度 == 1.0:
		# 移动指针
		当前节点.更新进度(0)
		制作指针 += 1
		# 指针超出队列长度或所有后续节点是null，重置为0
		if 制作指针 >= 制作队列名称.size() or 制作队列名称[制作指针].配方序号 == null:
			制作指针 = 0
	进度动画播放中=false

func 制作队列更新(按键信号,i):
	if 按键信号.button_index == MOUSE_BUTTON_LEFT:
		引擎.屏幕.滚动提示( "合成队列可以右键移除","手工提示")
	elif 按键信号.button_index == MOUSE_BUTTON_RIGHT:
		var 制作队列 = 初始化.梅存档.get("手工",{}).get("制作队列", [])# 获取当前制作队列
		# 检查索引是否有效（在数组范围内）
		if i >= 0 and i < 制作队列.size():
			# 获取要删除的装备名称
			var 装备名称 = 制作队列[i]
			# 从队列中移除该元素
			制作队列.erase(制作队列[i])
			# 更新存档
			初始化.梅存档["手工"].set("制作队列", 制作队列)
			# 显示提示信息
			引擎.屏幕.滚动提示( "已从制作队列移除:"+装备名称,"手工提示")
			# 刷新进度条显示
			初始化.节点["合成界面"].注册进度条()
		# 索引无效时什么也不做
	else :
		pass
