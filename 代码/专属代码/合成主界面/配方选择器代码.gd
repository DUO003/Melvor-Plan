extends GridContainer

var 筛选器节点
var 类型 = ""

func _ready():
	筛选器节点 = $"../../../筛选器/筛选器"
	配方初始化()

func 配方初始化():
	# 从筛选器节点获取类型变量的值
	类型 = 筛选器节点.类型
	# 保存原始配方节点的引用
	var 原始配方节点 = null
	# 遍历并删除除"配方"外的所有子节点
	for 子节点 in get_children():
		if 子节点.name == "配方":
			原始配方节点 = 子节点
			原始配方节点.visible = false  # 设置原始配方节点不可见
		else:
			子节点.queue_free()  # 安全删除其他节点
	# 如果存在原始配方节点，获取配方并克隆
	if 原始配方节点 != null:
		var 配方列表 = 获取配方(类型)
		克隆配方节点(原始配方节点, 配方列表)

@warning_ignore("unused_parameter")
func 获取配方(类型参数):
	# 暂时直接返回固定数组，实际使用时会根据类型参数获取数据
	return ["标准剑", "青铜剑", "铁剑"]

func 克隆配方节点(原始节点, 配方列表):
	# 根据配方列表数量克隆节点
	var 编号数组=梅表格.获取表格信息数组(梅表格.装备蓝图,配方列表,"名称")
	for i in range(配方列表.size()):
		var 配方名称=配方列表[i]
		var 配方编号=int(编号数组[i])
		var 克隆节点:Button = 原始节点.duplicate()

		克隆节点.name = "配方" + str(i + 1)  # 命名为配方1、配方2...
		克隆节点.visible = true  # 克隆节点设为可见
		# 可以在这里设置克隆节点的其他属性
		# 获取克隆节点下的"配方名"Label节点并设置文本
		var 配方名标签 = 克隆节点.get_node("配方名")
		var 解锁=true
		if 配方名标签 != null and 配方名标签 is Label:
			if 配方解锁(配方名称):
				配方名标签.text = 配方列表[i]
				var 配方等级 = 初始化.梅存档.get("手工",{}).get(配方名称, 0)
				var 残缺配方 = 初始化.梅存档.get("手工",{}).get(配方名称+"碎片", 0)
				if 残缺配方==0:
					克隆节点.text=""
				else:
					if 配方等级==0:
						克隆节点.text="残缺图纸*"+str(残缺配方)+"\n\n\n\n"
					else:
						克隆节点.text="研究任务*"+str(残缺配方)+"\n\n\n\n"
					
			else :
				克隆节点.text=""
				配方名标签.text = "未解锁"
				解锁=not true
		var 图片路径 = 梅表格.获取表格信息(梅表格.装备蓝图,配方名称,"icon")
		if 图片路径 == "":
			print("无法加载图片: ", 图片路径)
			图片路径="res://素材/像素/框.png"
		处理样式(克隆节点,图片路径,解锁)
			
		# 连接鼠标进入信号（传递配方编号作为参数）
		克隆节点.mouse_entered.connect(func(): 鼠标进入(配方编号))
		# 连接鼠标离开信号
		克隆节点.mouse_exited.connect(func(): 鼠标离开(配方编号))
		# 确保节点可以接收鼠标事件
		克隆节点.gui_input.connect(func(按键信号): 
			if 按键信号 is InputEventMouseButton and 按键信号.pressed:
				鼠标点击(配方编号, 按键信号))
		克隆节点.mouse_filter = Control.MOUSE_FILTER_STOP
		克隆节点.focus_mode = Control.FOCUS_NONE
		add_child(克隆节点)
# 功能：复制 Button 节点的 normal 原始样式，修改后批量赋值给 pressed/hover/focus 状态
# 参数1：节点 - 目标 Button 节点（如你的“克隆节点”）
# 参数2：图片 - 要替换的图片路径（例："res://images/btn_bg.png"）
func 处理样式(节点: Button, 图片: String, 解锁: bool) -> void:
	var 纹理 = load(图片)# 1. 加载图片
	var 样式 = 节点.get_theme_stylebox("normal").duplicate(true)# 2. 复制样式模板
	样式.样式数组[2].texture = 纹理# 3. 修改复制后的基础样式（统一替换图片）
	if 解锁:# 4. 根据解锁状态设置调制颜色（白色/暗灰色）
		样式.样式数组[2].modulate_color =Color(1, 1, 1)
	else :
		样式.样式数组[2].modulate_color =Color(0.2, 0.2, 0.2)
	for state in ["normal", "pressed", "hover", "focus"]:# 5. 批量将修改后的基础样式，赋值给所有需要同步的状态
		节点.add_theme_stylebox_override(state, 样式)
# 鼠标进入事件处理方法
func 鼠标进入(配方序号):
	# 记录当前配方序号
	#print("配方序号: " , 配方序号)
	%悬浮面板.配方序号 = 配方序号
# 鼠标离开事件处理方法
func 鼠标离开(配方序号):
	# 只有当离开的是当前正在显示的配方时才隐藏
	if 配方序号 == %悬浮面板.配方序号:
		%悬浮面板.配方序号 = 0
# 鼠标事件处理方法
func 鼠标点击(配方序号,按键信号):
	var 装备名称 = 梅表格.装备蓝图[配方序号][0]
	if 按键信号.button_index == MOUSE_BUTTON_LEFT:
		if 配方解锁(装备名称):
			if 制作物品(配方序号)!=1:
				引擎.屏幕.滚动提示("材料不足，无法制作","手工提示")
		else:
			引擎.屏幕.滚动提示( "配方未解锁，无法制作","手工提示")
	elif 按键信号.button_index == MOUSE_BUTTON_RIGHT:
		# 修正制作队列的数据地址，从手工分类下获取
		var 制作队列 = 初始化.梅存档.get("手工",{}).get("制作队列", [])
		if 装备名称 in 制作队列:
			# 存在则移除
			制作队列.erase(装备名称)
			引擎.屏幕.滚动提示( "已从制作队列移除:"+装备名称,"手工提示")
		else:
			if 制作队列.size()<6:
				if 配方解锁(装备名称):
					制作队列.append(装备名称)
					引擎.屏幕.滚动提示( "已添加到制作队列:"+装备名称,"手工提示")
				else :
					引擎.屏幕.滚动提示( "配方未解锁，无法加入队列","手工提示")
			else :
				引擎.屏幕.滚动提示( "队列已满","手工提示")
		# 修正制作队列的保存路径，保存到手工分类下
		初始化.梅存档["手工"].set("制作队列", 制作队列)
		初始化.节点["合成界面"].注册进度条()
	else :
		引擎.屏幕.滚动提示( "中键点击","手工提示")
		



func 制作物品(配方序号):
	# 定义材料权重配置
	var 材料权重 = {
		"零件": 3,
		"精华": 9
	}
	# 获取配方对应的物品表格数据
	var 表格字典 = 梅表格.获取表格字典(梅表格.装备蓝图, 配方序号)
	if 表格字典 == {}:
		return 0.0  # 配方不存在，返回0进度
	var 物品名称 = 表格字典.get("名称", "")
	if 物品名称 == "":
		print("配方错误")
		return 0.0  # 配方错误返回0进度
	# 定义需要消耗的材料类型
	var 材料类型列表 = 初始化.材料对照.keys()
	var 材料足够 = true
	var 总需求权重 = 0.0
	var 当前满足权重 = 0.0
	# 检查材料并计算权重
	for 材料类型 in 材料类型列表:
		var 所需数量 = 表格字典.get(材料类型, 0)
		if 所需数量 > 0:
			var 当前数量 = 初始化.查看资源(材料类型)
			# 获取材料权重，默认为1
			var 权重 = 材料权重.get(材料类型, 1)
			# 累计总需求权重
			总需求权重 += 所需数量 * 权重
			# 累计当前满足的权重（不超过需求）
			var 满足数量 = min(当前数量, 所需数量)
			当前满足权重 += 满足数量 * 权重
			# 检查是否足够
			if 当前数量 < 所需数量:
				材料足够 = false
	
	if 材料足够:
		# 扣除所需材料
		for 材料类型 in 材料类型列表:
			var 所需数量 = 表格字典.get(材料类型, 0)
			初始化.获得资源(材料类型, -所需数量, true, false)
		# 残缺图纸逻辑
		var 图纸等级 = 初始化.梅存档.get("手工",{}).get(物品名称, 0)
		var 残缺图纸等级=初始化.梅存档.get("手工",{}).get(物品名称+"碎片", 0)
		if 残缺图纸等级>=1:
			if randf()<0.1+0.005*图纸等级:
				var 图纸等阶=int(梅表格.获取表格信息(梅表格.装备蓝图,物品名称,"阶级"))
				var 蓝图纸奖励=int(16*残缺图纸等级*(10+图纸等阶*5)*(randf()+0.1*图纸等阶))
				初始化.语法糖获得物品("蓝图纸",蓝图纸奖励)
				初始化.梅存档["手工"][物品名称+"碎片"]=0
				引擎.屏幕.滚动提示( "研究完成,蓝图纸奖励+" + str(蓝图纸奖励))
				配方初始化()
		# 获得制作的物品及相关处理
		引擎.屏幕.滚动提示( "制作成功:" + str(物品名称))
		初始化.获得物品语法糖(物品名称, 1, "标准物品")
		if 图纸等级>=1:
			初始化.语法糖_快速熟练精通("手工熟练", "手工", 物品名称)
		else :
			初始化.语法糖_快速熟练精通("手工熟练", "手工", null)
		初始化.emit_signal("更新_UI")
		return 1.0  # 制作成功返回1
	else:
		# 计算进度（避免除零错误）
		var 进度 = 0.0
		if 总需求权重 > 0:
			进度 = 当前满足权重 / 总需求权重
			进度 = clamp(进度, 0.0, 1.0)  # 确保进度在0-1范围内
		#print("材料不足，无法制作，当前进度: ", 进度)
		return 进度
func 配方解锁(配方名称):
	var 配方等级 = 初始化.梅存档.get("手工",{}).get(配方名称, 0)
	var 残缺配方 = 初始化.梅存档.get("手工",{}).get(配方名称+"碎片", 0)
	if 配方等级>=1 or 残缺配方>=1:
		return true
	return false
